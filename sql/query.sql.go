// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sql

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const approveDriver = `-- name: ApproveDriver :exec
UPDATE DriverT set 
  approved_date =  NOW()
where id = $1
`

func (q *Queries) ApproveDriver(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, approveDriver, id)
	return err
}

const approveFinishedJob = `-- name: ApproveFinishedJob :exec
Update ClaimJobT set memo =$3, Approved_By = $2, approved_date = NOW(), last_modified_date = NOW() where id = $1
`

type ApproveFinishedJobParams struct {
	ID         int64
	ApprovedBy sql.NullInt64
	Memo       sql.NullString
}

func (q *Queries) ApproveFinishedJob(ctx context.Context, arg ApproveFinishedJobParams) error {
	_, err := q.db.ExecContext(ctx, approveFinishedJob, arg.ID, arg.ApprovedBy, arg.Memo)
	return err
}

const approveRepair = `-- name: ApproveRepair :exec
Update repairT set approved_date = NOW(), last_modified_date = NOW() where id =$1
`

func (q *Queries) ApproveRepair(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, approveRepair, id)
	return err
}

const approveRepairPic = `-- name: ApproveRepairPic :exec
Update RepairPicT Set
Approved_Date = NOW(),
last_modified_date = NOW()
where repair_id = $1
`

func (q *Queries) ApproveRepairPic(ctx context.Context, repairID int64) error {
	_, err := q.db.ExecContext(ctx, approveRepairPic, repairID)
	return err
}

const claimJob = `-- name: ClaimJob :one
INSERT into ClaimJobT (
    jobID,
    driverID
) values (
    $1,
    $2
) RETURNING id
`

type ClaimJobParams struct {
	Jobid    int64
	Driverid int64
}

func (q *Queries) ClaimJob(ctx context.Context, arg ClaimJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, claimJob, arg.Jobid, arg.Driverid)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO UserT(
    pwd, name, role, belongcmp, phoneNum
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateAdminParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp int64
	Phonenum  interface{}
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAdmin,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO AlertT (alert, belongCMP) values ($1, $2) RETURNING id
`

type CreateAlertParams struct {
	Alert     string
	Belongcmp int64
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAlert, arg.Alert, arg.Belongcmp)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDriverInfo = `-- name: CreateDriverInfo :one
insert into driverT (id,nationalidnumber, plateNum) 
    values ($1, $2, $3)
RETURNING id
`

type CreateDriverInfoParams struct {
	ID               int64
	Nationalidnumber interface{}
	Platenum         string
}

func (q *Queries) CreateDriverInfo(ctx context.Context, arg CreateDriverInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDriverInfo, arg.ID, arg.Nationalidnumber, arg.Platenum)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO JobsT (
    from_loc,
    mid,
    to_loc,
    price,
    estimated,
    remaining,
    belongCMP,
    source,
    -- jobDate,
    memo
    -- close_date
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $5,
    $6,
    $7,
    $8
    -- $9
    -- $10
) RETURNING id
`

type CreateJobParams struct {
	FromLoc   string
	Mid       sql.NullString
	ToLoc     string
	Price     int32
	Estimated int32
	Belongcmp int64
	Source    string
	Memo      sql.NullString
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Price,
		arg.Estimated,
		arg.Belongcmp,
		arg.Source,
		arg.Memo,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNewRepair = `-- name: CreateNewRepair :one
INSERT into repairT (type, driverID, repairInfo) values ($1, $2, $3) RETURNING id
`

type CreateNewRepairParams struct {
	Type       string
	Driverid   int64
	Repairinfo json.RawMessage
}

func (q *Queries) CreateNewRepair(ctx context.Context, arg CreateNewRepairParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewRepair, arg.Type, arg.Driverid, arg.Repairinfo)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO UserT(
    pwd, name, role, belongcmp, phoneNum
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateUserParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp int64
	Phonenum  interface{}
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const decreaseRemaining = `-- name: DecreaseRemaining :one
Update JobsT set remaining = remaining - 1, last_modified_date = NOW() where id = $1 RETURNING remaining
`

func (q *Queries) DecreaseRemaining(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRowContext(ctx, decreaseRemaining, id)
	var remaining int32
	err := row.Scan(&remaining)
	return remaining, err
}

const deleteAlert = `-- name: DeleteAlert :exec
Update AlertT Set
deleted_date = NOW(),
last_modified_date = NOW()
where id = $1
`

func (q *Queries) DeleteAlert(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAlert, id)
	return err
}

const deleteClaimedJob = `-- name: DeleteClaimedJob :exec
Update ClaimJobT Set
    deleted_by = $2,
    deleted_date = NOW(),
    last_modified_date = NOW()
    where id = $1
`

type DeleteClaimedJobParams struct {
	ID        int64
	DeletedBy sql.NullInt64
}

func (q *Queries) DeleteClaimedJob(ctx context.Context, arg DeleteClaimedJobParams) error {
	_, err := q.db.ExecContext(ctx, deleteClaimedJob, arg.ID, arg.DeletedBy)
	return err
}

const deleteCmp = `-- name: DeleteCmp :exec
UPDATE cmpt
  set deleted_date= NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCmp(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCmp, id)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
UPDATE JobsT 
  set deleted_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const deleteRepair = `-- name: DeleteRepair :exec
Update repairT set deleted_date = NOW(), last_modified_date = NOW() where id =$1
`

func (q *Queries) DeleteRepair(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRepair, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE UserT
  set deleted_date= NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const finishClaimedJob = `-- name: FinishClaimedJob :exec
Update ClaimJobT Set
    finishPic =$3,
    finished_date = NOW(),
    -- percentage = (SELECT percentage from driverT where driverT.id = (SELECT driverID from ClaimJobT where ClaimJobT.id = $1)),
    last_modified_date = NOW()
WHERE id = $1 and ClaimJobT.Driverid = $2
`

type FinishClaimedJobParams struct {
	ID        int64
	Driverid  int64
	Finishpic sql.NullString
}

func (q *Queries) FinishClaimedJob(ctx context.Context, arg FinishClaimedJobParams) error {
	_, err := q.db.ExecContext(ctx, finishClaimedJob, arg.ID, arg.Driverid, arg.Finishpic)
	return err
}

const getAlert = `-- name: GetAlert :many
SELECT alertT.id as ID, cmpt.name as cmpName, alertT.belongCMP as cmpID, alertT.alert as alert, alertT.create_date as Createdate, alertT.Deleted_Date as Deletedate from alertT
inner join cmpt on alertT.Belongcmp = cmpt.id
where 
(alertT.id = $1 OR $1 IS NULL)AND
(belongCMP = $2 OR $2 IS NULL)AND
(alert like $3 OR $3 IS NULL)AND
((alertT.create_date > $4 OR $4 IS NULL)
 AND (alertT.create_date < $5 OR $5 IS NULL)) AND
((alertT.deleted_date > $6 OR $6 IS NULL)
 AND (alertT.deleted_date < $7 OR $7 IS NULL)) AND
((alertT.last_modified_date > $8 OR $8 IS NULL) 
AND (alertT.last_modified_date < $9 OR $9 IS NULL))
order by alertT.id desc
`

type GetAlertParams struct {
	ID                    sql.NullInt64
	BelongCMP             sql.NullInt64
	Alert                 sql.NullString
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	DeletedDateStart      sql.NullTime
	DeletedDateEnd        sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetAlertRow struct {
	ID         int64
	Cmpname    string
	Cmpid      int64
	Alert      string
	Createdate time.Time
	Deletedate sql.NullTime
}

func (q *Queries) GetAlert(ctx context.Context, arg GetAlertParams) ([]GetAlertRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlert,
		arg.ID,
		arg.BelongCMP,
		arg.Alert,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.DeletedDateStart,
		arg.DeletedDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlertRow
	for rows.Next() {
		var i GetAlertRow
		if err := rows.Scan(
			&i.ID,
			&i.Cmpname,
			&i.Cmpid,
			&i.Alert,
			&i.Createdate,
			&i.Deletedate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertByCmp = `-- name: GetAlertByCmp :many
SELECT id, alert, belongcmp, create_date, deleted_date, last_modified_date
from alertT
where belongCMP = $1 order by id desc
`

func (q *Queries) GetAlertByCmp(ctx context.Context, belongcmp int64) ([]Alertt, error) {
	rows, err := q.db.QueryContext(ctx, getAlertByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alertt
	for rows.Next() {
		var i Alertt
		if err := rows.Scan(
			&i.ID,
			&i.Alert,
			&i.Belongcmp,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllClaimedJobs = `-- name: GetAllClaimedJobs :many
SELECT ClaimJobT.id as id, JobsT.id as JobID, UserT.id as UserID, JobsT.From_Loc, JobsT.mid, JobsT.To_Loc, ClaimJobT.Create_Date, usert.name as userName, cmpt.name as cmpname, cmpT.id as cmpID, ClaimJobT.Approved_date as ApprovedDate, ClaimJobT.Finished_Date as FinishDate from ClaimJobT inner join JobsT on JobsT.id = ClaimJobT.JobId inner join UserT on UserT.id = ClaimJobT.Driverid inner join Cmpt on UserT.belongCMP = cmpt.id WHERE ClaimJobT.Deleted_date is  null
`

type GetAllClaimedJobsRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	FromLoc      string
	Mid          sql.NullString
	ToLoc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Finishdate   sql.NullTime
}

func (q *Queries) GetAllClaimedJobs(ctx context.Context) ([]GetAllClaimedJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllClaimedJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClaimedJobsRow
	for rows.Next() {
		var i GetAllClaimedJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Userid,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.CreateDate,
			&i.Username,
			&i.Cmpname,
			&i.Cmpid,
			&i.Approveddate,
			&i.Finishdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCmp = `-- name: GetAllCmp :many
SELECT id, name, create_date, deleted_date, last_modified_date from cmpt
`

func (q *Queries) GetAllCmp(ctx context.Context) ([]Cmpt, error) {
	rows, err := q.db.QueryContext(ctx, getAllCmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cmpt
	for rows.Next() {
		var i Cmpt
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsAdmin = `-- name: GetAllJobsAdmin :many

SELECT  jobst.id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, memo, jobst.create_date, jobst.deleted_date, jobst.last_modified_date, cmpt.id, name, cmpt.create_date, cmpt.deleted_date, cmpt.last_modified_date
from JobsT
inner join cmpt on JobsT.belongcmp = cmpt.id 
where 
(JobsT.id = $1 OR $1 IS NULL)AND
(JobsT.From_Loc= $2 OR $2 IS NULL)AND
(JobsT.Mid= $3 OR $3 IS NULL)AND
(JobsT.To_Loc= $4 OR $4 IS NULL)AND
(belongcmp = $5 OR $5 IS NULL)AND
(remaining <> $6 OR $6 IS NULL)AND
((JobsT.create_date > $7 OR $7 IS NULL)
 AND (JobsT.create_date < $8 OR $8 IS NULL)) AND
((JobsT.deleted_date > $9 OR $9 IS NULL)
 AND (JobsT.deleted_date < $10 OR $10 IS NULL)) AND
((JobsT.last_modified_date > $11 OR $11 IS NULL) 
AND (JobsT.last_modified_date < $12 OR $12 IS NULL))
`

type GetAllJobsAdminParams struct {
	ID                    sql.NullInt64
	FromLoc               sql.NullString
	Mid                   sql.NullString
	ToLoc                 sql.NullString
	Belongcmp             sql.NullInt64
	Remaining             sql.NullInt32
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	DeletedDateStart      sql.NullTime
	DeletedDateEnd        sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetAllJobsAdminRow struct {
	ID                 int64
	FromLoc            string
	Mid                sql.NullString
	ToLoc              string
	Price              int32
	Estimated          int32
	Remaining          int32
	Belongcmp          int64
	Source             string
	Memo               sql.NullString
	CreateDate         time.Time
	DeletedDate        sql.NullTime
	LastModifiedDate   time.Time
	ID_2               int64
	Name               string
	CreateDate_2       time.Time
	DeletedDate_2      sql.NullTime
	LastModifiedDate_2 time.Time
}

// AND
// ((JobsT.create_date > sqlc.narg('create_date_start') OR sqlc.narg('create_date_start') IS NULL)
//
//	AND (JobsT.create_date < sqlc.narg('create_date_end') OR sqlc.narg('create_date_end') IS NULL)) AND
//
// ((JobsT.deleted_date > sqlc.narg('deleted_date_start') OR sqlc.narg('deleted_date_start') IS NULL)
//
//	AND (JobsT.deleted_date < sqlc.narg('deleted_date_end') OR sqlc.narg('deleted_date_end') IS NULL)) AND
//
// ((JobsT.last_modified_date > sqlc.narg('last_modified_date_start') OR sqlc.narg('last_modified_date_start') IS NULL)
// AND (JobsT.last_modified_date < sqlc.narg('last_modified_date_end') OR sqlc.narg('last_modified_date_end') IS NULL));
// ((JobsT.close_date> sqlc.narg('close_date_start') OR sqlc.narg('close_date_start') IS NULL)
//
//	AND (JobsT.create_date < sqlc.narg('close_date_end') OR sqlc.narg('close_date_end') IS NULL)) AND
func (q *Queries) GetAllJobsAdmin(ctx context.Context, arg GetAllJobsAdminParams) ([]GetAllJobsAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsAdmin,
		arg.ID,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Belongcmp,
		arg.Remaining,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.DeletedDateStart,
		arg.DeletedDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsAdminRow
	for rows.Next() {
		var i GetAllJobsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Memo,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
			&i.ID_2,
			&i.Name,
			&i.CreateDate_2,
			&i.DeletedDate_2,
			&i.LastModifiedDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsByCmp = `-- name: GetAllJobsByCmp :many
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, memo, create_date, deleted_date, last_modified_date from JobsT where belongcmp = $1
`

func (q *Queries) GetAllJobsByCmp(ctx context.Context, belongcmp int64) ([]Jobst, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobst
	for rows.Next() {
		var i Jobst
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Memo,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsClient = `-- name: GetAllJobsClient :many
SELECT  
    JobsT.ID,
    JobsT.From_Loc,
    JobsT.Mid,
    JobsT.To_Loc,
    JobsT.Price,
    JobsT.Remaining,
    JobsT.Belongcmp,
    JobsT.Source,
    JobsT.Memo,
    -- JobsT.Close_Date,
    JobsT.deleted_date
from JobsT
inner join cmpt on JobsT.belongcmp = cmpt.id 
where 
(JobsT.id = $1 OR $1 IS NULL)AND
(JobsT.From_Loc= $2 OR $2 IS NULL)AND
(JobsT.Mid= $3 OR $3 IS NULL)AND
(JobsT.To_Loc= $4 OR $4 IS NULL)AND
(belongcmp = $5 OR $5 IS NULL)AND
(remaining <> 0)AND
(JobsT.deleted_date is NULL)
`

type GetAllJobsClientParams struct {
	ID        sql.NullInt64
	FromLoc   sql.NullString
	Mid       sql.NullString
	ToLoc     sql.NullString
	Belongcmp sql.NullInt64
}

type GetAllJobsClientRow struct {
	ID          int64
	FromLoc     string
	Mid         sql.NullString
	ToLoc       string
	Price       int32
	Remaining   int32
	Belongcmp   int64
	Source      string
	Memo        sql.NullString
	DeletedDate sql.NullTime
}

// (JobsT.close_date is NULL)AND
func (q *Queries) GetAllJobsClient(ctx context.Context, arg GetAllJobsClientParams) ([]GetAllJobsClientRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsClient,
		arg.ID,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Belongcmp,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsClientRow
	for rows.Next() {
		var i GetAllJobsClientRow
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Memo,
			&i.DeletedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByCmp = `-- name: GetClaimedJobByCmp :many
SELECT ClaimJobT.id as id, JobsT.id as JobID, UserT.id as UserID, JobsT.From_Loc, JobsT.mid, JobsT.To_Loc, ClaimJobT.Create_Date, usert.name as userName, cmpt.name as cmpname, cmpT.id as cmpID, ClaimJobT.Approved_date as ApprovedDate, ClaimJobT.Finished_Date as FinishDate from ClaimJobT inner join JobsT on JobsT.id = ClaimJobT.JobId inner join UserT on UserT.id = ClaimJobT.Driverid inner join Cmpt on UserT.belongCMP = cmpt.id WHERE ClaimJobT.Deleted_date is  null and UserT.belongCMP = $1
`

type GetClaimedJobByCmpRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	FromLoc      string
	Mid          sql.NullString
	ToLoc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Finishdate   sql.NullTime
}

func (q *Queries) GetClaimedJobByCmp(ctx context.Context, belongcmp int64) ([]GetClaimedJobByCmpRow, error) {
	rows, err := q.db.QueryContext(ctx, getClaimedJobByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClaimedJobByCmpRow
	for rows.Next() {
		var i GetClaimedJobByCmpRow
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Userid,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.CreateDate,
			&i.Username,
			&i.Cmpname,
			&i.Cmpid,
			&i.Approveddate,
			&i.Finishdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByDriverID = `-- name: GetClaimedJobByDriverID :many
SELECT ClaimJobT.id as id, JobsT.id as JobID, UserT.id as UserID, JobsT.From_Loc, JobsT.mid, JobsT.To_Loc, ClaimJobT.Create_Date, usert.name as userName, cmpt.name as cmpname, cmpT.id as cmpID, ClaimJobT.Approved_date as ApprovedDate, ClaimJobT.Finished_Date as FinishDate from ClaimJobT inner join JobsT on JobsT.id = ClaimJobT.JobId inner join UserT on UserT.id = ClaimJobT.Driverid inner join Cmpt on UserT.belongCMP = cmpt.id WHERE ClaimJobT.Deleted_date is  null and UserT.id = $1
`

type GetClaimedJobByDriverIDRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	FromLoc      string
	Mid          sql.NullString
	ToLoc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Finishdate   sql.NullTime
}

func (q *Queries) GetClaimedJobByDriverID(ctx context.Context, id int64) ([]GetClaimedJobByDriverIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getClaimedJobByDriverID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClaimedJobByDriverIDRow
	for rows.Next() {
		var i GetClaimedJobByDriverIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Userid,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.CreateDate,
			&i.Username,
			&i.Cmpname,
			&i.Cmpid,
			&i.Approveddate,
			&i.Finishdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByID = `-- name: GetClaimedJobByID :one
SELECT ClaimJobT.id as id, JobsT.id as JobID, UserT.id as UserID, JobsT.From_Loc, finished_date, finishPic, JobsT.mid, JobsT.To_Loc, ClaimJobT.Create_Date, usert.name as userName, cmpt.name as cmpname, cmpT.id as cmpID, ClaimJobT.Approved_date as ApprovedDate,
price from ClaimJobT inner join JobsT on JobsT.id = ClaimJobT.JobId inner join UserT on UserT.id = ClaimJobT.Driverid inner join Cmpt on UserT.belongCMP = cmpt.id inner join DriverT on driverT.id = UserT.id WHERE ClaimJobT.id = $1
`

type GetClaimedJobByIDRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	FromLoc      string
	FinishedDate sql.NullTime
	Finishpic    sql.NullString
	Mid          sql.NullString
	ToLoc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Price        int32
}

//	DriverT.percentage  as driverPercentage,
//
// ClaimJobT.percentage as percentage,
func (q *Queries) GetClaimedJobByID(ctx context.Context, id int64) (GetClaimedJobByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getClaimedJobByID, id)
	var i GetClaimedJobByIDRow
	err := row.Scan(
		&i.ID,
		&i.Jobid,
		&i.Userid,
		&i.FromLoc,
		&i.FinishedDate,
		&i.Finishpic,
		&i.Mid,
		&i.ToLoc,
		&i.CreateDate,
		&i.Username,
		&i.Cmpname,
		&i.Cmpid,
		&i.Approveddate,
		&i.Price,
	)
	return i, err
}

const getCmp = `-- name: GetCmp :one
SELECT cmpt.id, cmpt.name, cmpt.create_date, cmpt.deleted_date, cmpt.last_modified_date, usert.id, phonenum, pwd, usert.name, belongcmp, seed, role, initpwdchanged, usert.create_date, usert.deleted_date, usert.last_modified_date FROM cmpt
inner join usert
on cmpt.id = usert.belongcmp AND (usert.role=200 OR usert.role=100)
where cmpt.id = $1
`

type GetCmpRow struct {
	ID                 int64
	Name               string
	CreateDate         time.Time
	DeletedDate        sql.NullTime
	LastModifiedDate   time.Time
	ID_2               int64
	Phonenum           interface{}
	Pwd                string
	Name_2             string
	Belongcmp          int64
	Seed               sql.NullString
	Role               int16
	Initpwdchanged     bool
	CreateDate_2       time.Time
	DeletedDate_2      sql.NullTime
	LastModifiedDate_2 time.Time
}

func (q *Queries) GetCmp(ctx context.Context, id int64) (GetCmpRow, error) {
	row := q.db.QueryRowContext(ctx, getCmp, id)
	var i GetCmpRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
		&i.ID_2,
		&i.Phonenum,
		&i.Pwd,
		&i.Name_2,
		&i.Belongcmp,
		&i.Seed,
		&i.Role,
		&i.Initpwdchanged,
		&i.CreateDate_2,
		&i.DeletedDate_2,
		&i.LastModifiedDate_2,
	)
	return i, err
}

const getCurrentClaimedJob = `-- name: GetCurrentClaimedJob :one
SELECT t2.id as claimID,t2.create_date as claimDate, t1.from_loc, t1.mid, t1.to_loc, t1.price, t1.source, t1.memo, t1.id  FROM ClaimJobT t2 inner join JobsT t1 on t1.id = t2.jobID where t2.driverID = $1 and (t2.deleted_date IS NULL and t2.finished_date IS NULL) order by t2.create_date LIMIT 1
`

type GetCurrentClaimedJobRow struct {
	Claimid   int64
	Claimdate time.Time
	FromLoc   string
	Mid       sql.NullString
	ToLoc     string
	Price     int32
	Source    string
	Memo      sql.NullString
	ID        int64
}

func (q *Queries) GetCurrentClaimedJob(ctx context.Context, driverid int64) (GetCurrentClaimedJobRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentClaimedJob, driverid)
	var i GetCurrentClaimedJobRow
	err := row.Scan(
		&i.Claimid,
		&i.Claimdate,
		&i.FromLoc,
		&i.Mid,
		&i.ToLoc,
		&i.Price,
		&i.Source,
		&i.Memo,
		&i.ID,
	)
	return i, err
}

const getDriver = `-- name: GetDriver :one
SELECT UserT.id as ID, insurances, registration, driverLicense, TruckLicense, nationalidnumber, 
 cmpt.name as cmpName, usert.phoneNum, usert.name as userName, usert.belongCMP, usert.role, usert.initPwdChanged, DriverT.lastAlert, DriverT.Approved_date, UserT.Deleted_Date as Deleted_Date FROM  DriverT inner join usert on DriverT.id = UserT.id inner join cmpt on usert.belongCMP = cmpt.id where
DriverT.id = $1 LIMIT 1
`

type GetDriverRow struct {
	ID               int64
	Insurances       sql.NullString
	Registration     sql.NullString
	Driverlicense    sql.NullString
	Trucklicense     sql.NullString
	Nationalidnumber interface{}
	Cmpname          string
	Phonenum         interface{}
	Username         string
	Belongcmp        int64
	Role             int16
	Initpwdchanged   bool
	Lastalert        sql.NullInt64
	ApprovedDate     sql.NullTime
	DeletedDate      sql.NullTime
}

// percentage,
func (q *Queries) GetDriver(ctx context.Context, id int64) (GetDriverRow, error) {
	row := q.db.QueryRowContext(ctx, getDriver, id)
	var i GetDriverRow
	err := row.Scan(
		&i.ID,
		&i.Insurances,
		&i.Registration,
		&i.Driverlicense,
		&i.Trucklicense,
		&i.Nationalidnumber,
		&i.Cmpname,
		&i.Phonenum,
		&i.Username,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.Lastalert,
		&i.ApprovedDate,
		&i.DeletedDate,
	)
	return i, err
}

const getDriverRevenue = `-- name: GetDriverRevenue :many
SELECT
 coalesce(sum(t1.percentage), 0) as earn,
coalesce((select count(*) from ClaimJobT t1 where t1.driverID = $1 
 and (t1.finished_date IS NOT NULL and approved_date IS NOT NULL and t1.deleted_date IS NULL) 
and date(t1.finished_date) >= date($2) and date(t1.finished_date) <= date($3)), 0) as count
from ClaimJobT t1 inner join JobsT t2 on t1.jobID = t2.id
where t1.driverID = $1 
and (t1.finished_date IS NOT NULL and approved_date IS NOT NULL and t1.deleted_date IS NULL) 
and date(t1.finished_date) >= date($2) and date(t1.finished_date) <= date($3)
`

type GetDriverRevenueParams struct {
	Driverid int64
	Date     interface{}
	Date_2   interface{}
}

type GetDriverRevenueRow struct {
	Earn  interface{}
	Count interface{}
}

func (q *Queries) GetDriverRevenue(ctx context.Context, arg GetDriverRevenueParams) ([]GetDriverRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getDriverRevenue, arg.Driverid, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriverRevenueRow
	for rows.Next() {
		var i GetDriverRevenueRow
		if err := rows.Scan(&i.Earn, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriverRevenueByCmp = `-- name: GetDriverRevenueByCmp :many
SELECT
 coalesce(sum(t2.price), 0) as earn,
coalesce((select count(*) from ClaimJobT t1 
inner join UserT t3 on t1.driverID = t3.id
where t3.belongCMP= $1 
and (t1.finished_date IS NOT NULL and approved_date IS NOT NULL and t1.deleted_date IS NULL) 
and  date(t1.finished_date) >= date($2) and date(t1.finished_date) <= date($3)), 0) as count
from ClaimJobT t1 inner join JobsT t2 on t1.jobID = t2.id
inner join UserT t3 on t1.driverID = t3.id
where t3.belongCMP= $1 
and (t1.finished_date IS NOT NULL and approved_date IS NOT NULL and t1.deleted_date IS NULL) 
and date(t1.finished_date) >= date($2) and date(t1.finished_date) <= date($3)
`

type GetDriverRevenueByCmpParams struct {
	Belongcmp int64
	Date      interface{}
	Date_2    interface{}
}

type GetDriverRevenueByCmpRow struct {
	Earn  interface{}
	Count interface{}
}

func (q *Queries) GetDriverRevenueByCmp(ctx context.Context, arg GetDriverRevenueByCmpParams) ([]GetDriverRevenueByCmpRow, error) {
	rows, err := q.db.QueryContext(ctx, getDriverRevenueByCmp, arg.Belongcmp, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriverRevenueByCmpRow
	for rows.Next() {
		var i GetDriverRevenueByCmpRow
		if err := rows.Scan(&i.Earn, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobById = `-- name: GetJobById :one
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, memo, create_date, deleted_date, last_modified_date from JobsT where id = $1 LIMIT 1
`

func (q *Queries) GetJobById(ctx context.Context, id int64) (Jobst, error) {
	row := q.db.QueryRowContext(ctx, getJobById, id)
	var i Jobst
	err := row.Scan(
		&i.ID,
		&i.FromLoc,
		&i.Mid,
		&i.ToLoc,
		&i.Price,
		&i.Estimated,
		&i.Remaining,
		&i.Belongcmp,
		&i.Source,
		&i.Memo,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getLastAlert = `-- name: GetLastAlert :one
SELECT lastAlert from driverT where id = $1
`

func (q *Queries) GetLastAlert(ctx context.Context, id int64) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, getLastAlert, id)
	var lastalert sql.NullInt64
	err := row.Scan(&lastalert)
	return lastalert, err
}

const getRepair = `-- name: GetRepair :many
SELECT repairT.id as ID, UserT.id as Driverid, UserT.Name as Drivername, repairT.type as type, repairT.Repairinfo as Repairinfo, repairT.Create_Date as CreateDate, repairT.Approved_Date as ApprovedDate
from repairT 
inner join UserT on UserT.id = repairT.driverID
where 
(repairT.id = $1 OR $1 IS NULL)AND
(repairT.driverID = $2 OR $2 IS NULL)AND
(UserT.name = $3 OR $3 IS NULL)AND
(UserT.belongcmp = $4 OR $4 IS NULL)AND
((repairT.create_date > $5 OR $5 IS NULL)
 AND (repairT.create_date < $6 OR $6 IS NULL)) AND
repairT.deleted_date is null AND
((repairT.last_modified_date > $7 OR $7 IS NULL) 
AND (repairT.last_modified_date < $8 OR $8 IS NULL))
`

type GetRepairParams struct {
	ID                    sql.NullInt64
	DriverID              sql.NullInt64
	Name                  sql.NullString
	Belongcmp             sql.NullInt64
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetRepairRow struct {
	ID           int64
	Driverid     int64
	Drivername   string
	Type         string
	Repairinfo   json.RawMessage
	Createdate   time.Time
	Approveddate sql.NullTime
}

func (q *Queries) GetRepair(ctx context.Context, arg GetRepairParams) ([]GetRepairRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepair,
		arg.ID,
		arg.DriverID,
		arg.Name,
		arg.Belongcmp,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepairRow
	for rows.Next() {
		var i GetRepairRow
		if err := rows.Scan(
			&i.ID,
			&i.Driverid,
			&i.Drivername,
			&i.Type,
			&i.Repairinfo,
			&i.Createdate,
			&i.Approveddate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepairById = `-- name: GetRepairById :one
SELECT id, type, driverid, repairinfo, create_date, approved_date, deleted_date, last_modified_date from repairT where id = $1
`

func (q *Queries) GetRepairById(ctx context.Context, id int64) (Repairt, error) {
	row := q.db.QueryRowContext(ctx, getRepairById, id)
	var i Repairt
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Driverid,
		&i.Repairinfo,
		&i.CreateDate,
		&i.ApprovedDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getRevenueExcel = `-- name: GetRevenueExcel :many
SELECT usert.id, DriverT.plateNum as plateNum, UserT.Name as Username,jobst.belongCMP as belongCMP,
	jobst.from_loc as FromLoc, jobst.mid as mid, jobst.to_loc as ToLoc, count(*), 
	jobst.price, jobst.price*count(*) as totalPrice,
    jobst.source,
	cmpt.name,
  --  (ClaimJobt.Percentage/100)*jobst.price*count(*) as togive,
    date(ClaimJobt.approved_date) as ApprovedDate
    ,ClaimJobt.Memo 
	from JobsT
left join ClaimJobT on ClaimJobT.JobID = JobsT.id
left join UserT on UserT.id = ClaimJobT.Driverid
left join cmpt on cmpt.id = usert.belongcmp
left join driverT on UserT.id = driverT.id
where (Claimjobt.deleted_date is null) and (ClaimJobT.Approved_Date is not null) and (ClaimJobT.Approved_date between $1 and $2) 
group by usert.id, jobid,DriverT.plateNum,  UserT.Name, jobst.from_loc, jobst.mid, jobst.to_loc, jobst.price,cmpt.name, 
jobst.belongCMP,
jobst.source, date(Claimjobt.approved_date), ClaimJobt.Memo
`

type GetRevenueExcelParams struct {
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
}

type GetRevenueExcelRow struct {
	ID           sql.NullInt64
	Platenum     sql.NullString
	Username     sql.NullString
	Belongcmp    int64
	Fromloc      string
	Mid          sql.NullString
	Toloc        string
	Count        int64
	Price        int32
	Totalprice   int32
	Source       string
	Name         sql.NullString
	Approveddate time.Time
	Memo         sql.NullString
}

// ClaimJobT.percentage,
func (q *Queries) GetRevenueExcel(ctx context.Context, arg GetRevenueExcelParams) ([]GetRevenueExcelRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueExcel, arg.ApprovedDate, arg.ApprovedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueExcelRow
	for rows.Next() {
		var i GetRevenueExcelRow
		if err := rows.Scan(
			&i.ID,
			&i.Platenum,
			&i.Username,
			&i.Belongcmp,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.Count,
			&i.Price,
			&i.Totalprice,
			&i.Source,
			&i.Name,
			&i.Approveddate,
			&i.Memo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, role, deleted_date,pwd FROM  UserT
WHERE phoneNum=$1  LIMIT 1
`

type GetUserRow struct {
	ID          int64
	Role        int16
	DeletedDate sql.NullTime
	Pwd         string
}

func (q *Queries) GetUser(ctx context.Context, phonenum interface{}) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, phonenum)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.DeletedDate,
		&i.Pwd,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
UserT.id as ID, cmpt.name as Cmpname, usert.phoneNum as phoneNum, usert.name as Username, usert.belongCMP, usert.role, usert.initPwdChanged, UserT.Deleted_Date as Deleted_Date, insurances, registration, driverLicense, TruckLicense, nationalidnumber,
plateNum, Approved_date
from UserT 
inner join cmpt on UserT.belongcmp = cmpt.id 
left join DriverT on driverT.id= usert.id 
where UserT.id=$1 LIMIT 1
`

type GetUserByIDRow struct {
	ID               int64
	Cmpname          string
	Phonenum         interface{}
	Username         string
	Belongcmp        int64
	Role             int16
	Initpwdchanged   bool
	DeletedDate      sql.NullTime
	Insurances       sql.NullString
	Registration     sql.NullString
	Driverlicense    sql.NullString
	Trucklicense     sql.NullString
	Nationalidnumber interface{}
	Platenum         sql.NullString
	ApprovedDate     sql.NullTime
}

// percentage,
func (q *Queries) GetUserByID(ctx context.Context, id int64) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Cmpname,
		&i.Phonenum,
		&i.Username,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.DeletedDate,
		&i.Insurances,
		&i.Registration,
		&i.Driverlicense,
		&i.Trucklicense,
		&i.Nationalidnumber,
		&i.Platenum,
		&i.ApprovedDate,
	)
	return i, err
}

const getUserList = `-- name: GetUserList :many
SELECT json_build_object('cmpid', cmpt.id, 'Cmpname', cmpt.name, 'list'
    , 
	json_agg(json_build_object('id',UT.id, 
	'phoneNum', UT.phonenum,
	'Role', UT.Role,
	'Username', UT.name,
	'deleted_date',UT.deleted_date,
	'last_modified_date', UT.last_modified_date
	))
    )

from UserT UT
right join cmpt on UT.belongcmp = cmpt.id
where 
(UT.id = $1 OR $1 IS NULL)AND
(phoneNum = $2::Text OR $2::Text IS NULL)AND
(UT.name like $3 OR $3 IS NULL)AND
(belongcmp = $4 OR $4 IS NULL)AND
(cmpt.Name like $5 OR $5 IS NULL)AND
((UT.create_date > $6 OR $6 IS NULL)
 AND (UT.create_date < $7 OR $7 IS NULL)) AND
((UT.deleted_date > $8 OR $8 IS NULL)
 AND (UT.deleted_date < $9 OR $9 IS NULL)) AND
((UT.last_modified_date > $10 OR $10 IS NULL) 
AND (UT.last_modified_date < $11 OR $11 IS NULL))
group by cmpt.id
`

type GetUserListParams struct {
	ID                    sql.NullInt64
	PhoneNum              sql.NullString
	Name                  sql.NullString
	Belongcmp             sql.NullInt64
	BelongcmpName         sql.NullString
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	DeletedDateStart      sql.NullTime
	DeletedDateEnd        sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

func (q *Queries) GetUserList(ctx context.Context, arg GetUserListParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getUserList,
		arg.ID,
		arg.PhoneNum,
		arg.Name,
		arg.Belongcmp,
		arg.BelongcmpName,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.DeletedDateStart,
		arg.DeletedDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var json_build_object json.RawMessage
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSeed = `-- name: GetUserSeed :one
SELECT seed from UserT 
inner join cmpt on UserT.belongcmp = cmpt.id 
where UserT.id=$1 LIMIT 1
`

func (q *Queries) GetUserSeed(ctx context.Context, id int64) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getUserSeed, id)
	var seed sql.NullString
	err := row.Scan(&seed)
	return seed, err
}

const increaseRemaining = `-- name: IncreaseRemaining :one
Update JobsT set remaining = remaining + 1, last_modified_date = NOW() where id = $1 RETURNING remaining
`

func (q *Queries) IncreaseRemaining(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRowContext(ctx, increaseRemaining, id)
	var remaining int32
	err := row.Scan(&remaining)
	return remaining, err
}

const newCmp = `-- name: NewCmp :one
INSERT INTO cmpt (name) values ($1) RETURNING id
`

func (q *Queries) NewCmp(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, newCmp, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const newSeed = `-- name: NewSeed :exec
UPDATE UserT set 
  seed = $2,
  last_modified_date = NOW()
WHERE id = $1
`

type NewSeedParams struct {
	ID   int64
	Seed sql.NullString
}

func (q *Queries) NewSeed(ctx context.Context, arg NewSeedParams) error {
	_, err := q.db.ExecContext(ctx, newSeed, arg.ID, arg.Seed)
	return err
}

const setJobNoMore = `-- name: SetJobNoMore :exec
UPDATE JobsT 
  set finished_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) SetJobNoMore(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setJobNoMore, id)
	return err
}

const updateAlert = `-- name: UpdateAlert :exec
Update AlertT Set
alert = $2,
last_modified_date = NOW()
where id = $1
`

type UpdateAlertParams struct {
	ID    int64
	Alert string
}

func (q *Queries) UpdateAlert(ctx context.Context, arg UpdateAlertParams) error {
	_, err := q.db.ExecContext(ctx, updateAlert, arg.ID, arg.Alert)
	return err
}

const updateCmp = `-- name: UpdateCmp :exec
UPDATE cmpt
    set
    name = $2,
    last_modified_date = NOW()
WHERE id = $1
`

type UpdateCmpParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpdateCmp(ctx context.Context, arg UpdateCmpParams) error {
	_, err := q.db.ExecContext(ctx, updateCmp, arg.ID, arg.Name)
	return err
}

const updateDriver = `-- name: UpdateDriver :exec
UPDATE DriverT set 
  -- percentage = COALESCE($2, percentage),
  nationalidnumber = COALESCE($2, nationalidnumber),
  plateNum = COALESCE($3, plateNum)
WHERE id = $1
`

type UpdateDriverParams struct {
	ID               int64
	Nationalidnumber interface{}
	Platenum         string
}

func (q *Queries) UpdateDriver(ctx context.Context, arg UpdateDriverParams) error {
	_, err := q.db.ExecContext(ctx, updateDriver, arg.ID, arg.Nationalidnumber, arg.Platenum)
	return err
}

const updateDriverPic = `-- name: UpdateDriverPic :exec
UPDATE DriverT set 
  insurances = COALESCE($2, insurances),
  registration = COALESCE($3, registration),
  driverLicense = COALESCE($4, driverLicense),
  truckLicense = COALESCE($5, truckLicense),
  approved_date = NULL
WHERE DriverT.id = $1
`

type UpdateDriverPicParams struct {
	ID            int64
	Insurances    sql.NullString
	Registration  sql.NullString
	Driverlicense sql.NullString
	Trucklicense  sql.NullString
}

func (q *Queries) UpdateDriverPic(ctx context.Context, arg UpdateDriverPicParams) error {
	_, err := q.db.ExecContext(ctx, updateDriverPic,
		arg.ID,
		arg.Insurances,
		arg.Registration,
		arg.Driverlicense,
		arg.Trucklicense,
	)
	return err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobsT set 
    from_loc = $1,
    mid = $2,
    to_loc = $3,
    price = $4,
    remaining = $5,
    belongCMP = $6,
    source = $7,
    -- jobDate = $8,
    memo = $8,
    -- close_date = $9,
    last_modified_date = NOW()
where id = $9
 RETURNING id
`

type UpdateJobParams struct {
	FromLoc   string
	Mid       sql.NullString
	ToLoc     string
	Price     int32
	Remaining int32
	Belongcmp int64
	Source    string
	Memo      sql.NullString
	ID        int64
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateJob,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Price,
		arg.Remaining,
		arg.Belongcmp,
		arg.Source,
		arg.Memo,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateLastAlert = `-- name: UpdateLastAlert :exec
Update driverT set
lastAlert = $2
where id = $1
`

type UpdateLastAlertParams struct {
	ID        int64
	Lastalert sql.NullInt64
}

func (q *Queries) UpdateLastAlert(ctx context.Context, arg UpdateLastAlertParams) error {
	_, err := q.db.ExecContext(ctx, updateLastAlert, arg.ID, arg.Lastalert)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE UserT set 
  phoneNum = COALESCE($2, phoneNum),
  name = COALESCE($3, name),
  belongCMP = COALESCE($4, belongCMP),
  role = COALESCE($5, role),
  last_modified_date = NOW()
WHERE UserT.id = $1
`

type UpdateUserParams struct {
	ID        int64
	Phonenum  interface{}
	Name      string
	Belongcmp int64
	Role      int16
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Phonenum,
		arg.Name,
		arg.Belongcmp,
		arg.Role,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE UserT set 
  pwd = $2,
  initPwdChanged = True,
  last_modified_date = NOW()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID  int64
	Pwd string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.ID, arg.Pwd)
	return err
}

const uploadRepairPic = `-- name: UploadRepairPic :exec
insert into RepairPicT (repair_id, pic) values ($1, $2)
`

type UploadRepairPicParams struct {
	RepairID int64
	Pic      sql.NullString
}

func (q *Queries) UploadRepairPic(ctx context.Context, arg UploadRepairPicParams) error {
	_, err := q.db.ExecContext(ctx, uploadRepairPic, arg.RepairID, arg.Pic)
	return err
}

const userHasModified = `-- name: UserHasModified :exec
UPDATE UserT set 
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) UserHasModified(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, userHasModified, id)
	return err
}
