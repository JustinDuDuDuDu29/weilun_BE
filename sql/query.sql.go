// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sql

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const approveDriver = `-- name: ApproveDriver :exec
UPDATE DriverT
set approved_date = NOW()
where id = $1
`

func (q *Queries) ApproveDriver(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, approveDriver, id)
	return err
}

const approveFinishedJob = `-- name: ApproveFinishedJob :exec
Update ClaimJobT
set memo = $3,
  Approved_By = $2,
  approved_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

type ApproveFinishedJobParams struct {
	ID         int64
	ApprovedBy sql.NullInt64
	Memo       sql.NullString
}

func (q *Queries) ApproveFinishedJob(ctx context.Context, arg ApproveFinishedJobParams) error {
	_, err := q.db.ExecContext(ctx, approveFinishedJob, arg.ID, arg.ApprovedBy, arg.Memo)
	return err
}

const approveGas = `-- name: ApproveGas :exec
Update GasT
set approved_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

func (q *Queries) ApproveGas(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, approveGas, id)
	return err
}

const approveMultipleJobs = `-- name: ApproveMultipleJobs :exec
UPDATE ClaimJobT
SET 
  memo = $1,
  approved_by = $2,
  approved_date = NOW(),
  last_modified_date = NOW()
WHERE id = ANY($3::bigint[])
`

type ApproveMultipleJobsParams struct {
	Memo       sql.NullString
	ApprovedBy sql.NullInt64
	Ids        []int64
}

func (q *Queries) ApproveMultipleJobs(ctx context.Context, arg ApproveMultipleJobsParams) error {
	_, err := q.db.ExecContext(ctx, approveMultipleJobs, arg.Memo, arg.ApprovedBy, pq.Array(arg.Ids))
	return err
}

const approveRepair = `-- name: ApproveRepair :exec
Update repairT
set approved_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

func (q *Queries) ApproveRepair(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, approveRepair, id)
	return err
}

const claimJob = `-- name: ClaimJob :one
INSERT into ClaimJobT (jobID, driverID)
values ($1, $2)
RETURNING id
`

type ClaimJobParams struct {
	Jobid    int64
	Driverid int64
}

func (q *Queries) ClaimJob(ctx context.Context, arg ClaimJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, claimJob, arg.Jobid, arg.Driverid)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO UserT(
    pwd,
    name,
    role,
    belongcmp,
    phoneNum,
    phoneNumInD
  )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateAdminParams struct {
	Pwd         string
	Name        string
	Role        int16
	Belongcmp   int64
	Phonenum    interface{}
	Phonenumind interface{}
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAdmin,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
		arg.Phonenumind,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO AlertT (alert, belongCMP)
values ($1, $2)
RETURNING id
`

type CreateAlertParams struct {
	Alert     string
	Belongcmp int64
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAlert, arg.Alert, arg.Belongcmp)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDriverInfo = `-- name: CreateDriverInfo :one
insert into driverT (id, nationalidnumber, plateNum)
values ($1, $2, $3)
RETURNING id
`

type CreateDriverInfoParams struct {
	ID               int64
	Nationalidnumber interface{}
	Platenum         string
}

func (q *Queries) CreateDriverInfo(ctx context.Context, arg CreateDriverInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDriverInfo, arg.ID, arg.Nationalidnumber, arg.Platenum)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO JobsT (
    fromLoc,
    mid,
    toLoc,
    price,
    estimated,
    remaining,
    belongCMP,
    source,
    -- jobDate,
    memo -- close_date
  )
values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $5,
    $6,
    $7,
    $8 -- $9
    -- $10
  )
RETURNING id
`

type CreateJobParams struct {
	Fromloc   string
	Mid       sql.NullString
	Toloc     string
	Price     int32
	Estimated int32
	Belongcmp int64
	Source    string
	Memo      sql.NullString
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.Fromloc,
		arg.Mid,
		arg.Toloc,
		arg.Price,
		arg.Estimated,
		arg.Belongcmp,
		arg.Source,
		arg.Memo,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNewGas = `-- name: CreateNewGas :one
INSERT into GasT (driverID, pic)
values ($1, $2)
RETURNING id
`

type CreateNewGasParams struct {
	Driverid int64
	Pic      sql.NullString
}

func (q *Queries) CreateNewGas(ctx context.Context, arg CreateNewGasParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewGas, arg.Driverid, arg.Pic)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNewGasInfo = `-- name: CreateNewGasInfo :one
INSERT into GasInfoT (gasID, itemName, quantity, totalPrice)
values ($1, $2, $3, $4)
RETURNING id
`

type CreateNewGasInfoParams struct {
	Gasid      int64
	Itemname   string
	Quantity   int32
	Totalprice int64
}

func (q *Queries) CreateNewGasInfo(ctx context.Context, arg CreateNewGasInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewGasInfo,
		arg.Gasid,
		arg.Itemname,
		arg.Quantity,
		arg.Totalprice,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNewRepair = `-- name: CreateNewRepair :one
INSERT into repairT (driverID, pic, place)
values ($1, $2, $3)
RETURNING id
`

type CreateNewRepairParams struct {
	Driverid int64
	Pic      sql.NullString
	Place    string
}

func (q *Queries) CreateNewRepair(ctx context.Context, arg CreateNewRepairParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewRepair, arg.Driverid, arg.Pic, arg.Place)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNewRepairInfo = `-- name: CreateNewRepairInfo :one
INSERT into repairInfoT (repairID, itemName, quantity, totalPrice)
values ($1, $2, $3, $4)
RETURNING id
`

type CreateNewRepairInfoParams struct {
	Repairid   int64
	Itemname   string
	Quantity   int32
	Totalprice int64
}

func (q *Queries) CreateNewRepairInfo(ctx context.Context, arg CreateNewRepairInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewRepairInfo,
		arg.Repairid,
		arg.Itemname,
		arg.Quantity,
		arg.Totalprice,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO UserT(
    pwd,
    name,
    role,
    belongcmp,
    phoneNum,
    phoneNumInD
  )
VALUES ($1, $2, $3, $4, $5, $5)
RETURNING id
`

type CreateUserParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp int64
	Phonenum  interface{}
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const decreaseRemaining = `-- name: DecreaseRemaining :one
Update JobsT
set remaining = remaining - 1,
  last_modified_date = NOW()
where id = $1
RETURNING remaining
`

func (q *Queries) DecreaseRemaining(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRowContext(ctx, decreaseRemaining, id)
	var remaining int32
	err := row.Scan(&remaining)
	return remaining, err
}

const deleteAlert = `-- name: DeleteAlert :exec
Update AlertT
Set deleted_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

func (q *Queries) DeleteAlert(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAlert, id)
	return err
}

const deleteClaimedJob = `-- name: DeleteClaimedJob :exec
Update ClaimJobT
Set deleted_by = $2,
  deleted_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

type DeleteClaimedJobParams struct {
	ID        int64
	DeletedBy sql.NullInt64
}

func (q *Queries) DeleteClaimedJob(ctx context.Context, arg DeleteClaimedJobParams) error {
	_, err := q.db.ExecContext(ctx, deleteClaimedJob, arg.ID, arg.DeletedBy)
	return err
}

const deleteCmp = `-- name: DeleteCmp :exec
UPDATE cmpt
set deleted_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCmp(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCmp, id)
	return err
}

const deleteGasT = `-- name: DeleteGasT :exec
Update gasT
set deleted_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

func (q *Queries) DeleteGasT(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGasT, id)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
UPDATE JobsT
set deleted_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const deleteRepair = `-- name: DeleteRepair :exec
Update repairT
set deleted_date = NOW(),
  last_modified_date = NOW()
where id = $1
`

func (q *Queries) DeleteRepair(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRepair, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE UserT
set deleted_date = NOW(),
  phoneNum = null,
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const finishClaimedJob = `-- name: FinishClaimedJob :exec
Update ClaimJobT
Set finishPic = $3,
  finished_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
  and ClaimJobT.Driverid = $2
`

type FinishClaimedJobParams struct {
	ID        int64
	Driverid  int64
	Finishpic sql.NullString
}

func (q *Queries) FinishClaimedJob(ctx context.Context, arg FinishClaimedJobParams) error {
	_, err := q.db.ExecContext(ctx, finishClaimedJob, arg.ID, arg.Driverid, arg.Finishpic)
	return err
}

const getAlert = `-- name: GetAlert :many
SELECT alertT.id as ID,
  cmpt.name as cmpName,
  alertT.belongCMP as cmpID,
  alertT.alert as alert,
  alertT.create_date as Createdate,
  alertT.Deleted_Date as Deletedate
from alertT
  inner join cmpt on alertT.Belongcmp = cmpt.id
where (
    alertT.id = $1
    OR $1 IS NULL
  )
  AND (
    belongCMP = $2
    OR $2 IS NULL
  )
  AND (
    alert like $3
    OR $3 IS NULL
  )
  AND (
    (
      alertT.create_date > $4
      OR $4 IS NULL
    )
    AND (
      alertT.create_date < $5
      OR $5 IS NULL
    )
  )
  AND (
    (
      alertT.deleted_date > $6
      OR $6 IS NULL
    )
    AND (
      alertT.deleted_date < $7
      OR $7 IS NULL
    )
  )
  AND (
    (
      alertT.last_modified_date > $8
      OR $8 IS NULL
    )
    AND (
      alertT.last_modified_date < $9
      OR $9 IS NULL
    )
  )
order by alertT.id desc
`

type GetAlertParams struct {
	ID                    sql.NullInt64
	BelongCMP             sql.NullInt64
	Alert                 sql.NullString
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	DeletedDateStart      sql.NullTime
	DeletedDateEnd        sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetAlertRow struct {
	ID         int64
	Cmpname    string
	Cmpid      int64
	Alert      string
	Createdate time.Time
	Deletedate sql.NullTime
}

func (q *Queries) GetAlert(ctx context.Context, arg GetAlertParams) ([]GetAlertRow, error) {
	rows, err := q.db.QueryContext(ctx, getAlert,
		arg.ID,
		arg.BelongCMP,
		arg.Alert,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.DeletedDateStart,
		arg.DeletedDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAlertRow
	for rows.Next() {
		var i GetAlertRow
		if err := rows.Scan(
			&i.ID,
			&i.Cmpname,
			&i.Cmpid,
			&i.Alert,
			&i.Createdate,
			&i.Deletedate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAlertByCmp = `-- name: GetAlertByCmp :many
SELECT id, alert, belongcmp, create_date, deleted_date, last_modified_date
from alertT
where belongCMP = $1
order by id desc
`

func (q *Queries) GetAlertByCmp(ctx context.Context, belongcmp int64) ([]Alertt, error) {
	rows, err := q.db.QueryContext(ctx, getAlertByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alertt
	for rows.Next() {
		var i Alertt
		if err := rows.Scan(
			&i.ID,
			&i.Alert,
			&i.Belongcmp,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllClaimedJobs = `-- name: GetAllClaimedJobs :many
SELECT ClaimJobT.id AS id,
  JobsT.id AS JobID,
  UserT.id AS UserID,
  JobsT.fromLoc AS fromloc,
  -- Aliased as fromloc
  JobsT.mid AS mid,
  JobsT.toLoc AS toloc,
  -- Aliased as toloc
  JobsT.Price,
  ClaimJobT.Create_Date,
  UserT.name AS userName,
  Cmpt.name AS cmpname,
  Cmpt.id AS cmpID,
  ClaimJobT.Approved_date AS ApprovedDate,
  ClaimJobT.Finished_Date AS FinishDate,
  ClaimJobT.finishPic
FROM ClaimJobT
  INNER JOIN JobsT ON JobsT.id = ClaimJobT.JobId
  INNER JOIN UserT ON UserT.id = ClaimJobT.Driverid
  INNER JOIN Cmpt ON UserT.belongCMP = Cmpt.id
WHERE ClaimJobT.Deleted_date IS NULL
  AND (
    ClaimJobT.driverid = $1
    OR $1 IS NULL
  )
  AND (
    ClaimJobT.jobID = $2
    OR $2 IS NULL
  )
  AND (
    UserT.belongCMP = $3
    OR $3 IS NULL
  )
  AND (
    ClaimJobT.id = $4
    OR $4 IS NULL
  )
  AND (
    (
      $5 = 'pending'
      AND ClaimJobT.Approved_date IS NULL
    )
    OR $5 IS NULL
  )
  AND (
    TO_CHAR(DATE(ClaimJobT.create_date), 'YYYY-MM') = TO_CHAR(DATE($6), 'YYYY-MM')
    OR $6 IS NULL
  )
  AND ClaimJobT.deleted_date IS NULL
`

type GetAllClaimedJobsParams struct {
	Uid   sql.NullInt64
	Jobid sql.NullInt64
	CmpID sql.NullInt64
	CjID  sql.NullInt64
	Cat   interface{}
	Ym    interface{}
}

type GetAllClaimedJobsRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	Fromloc      string
	Mid          sql.NullString
	Toloc        string
	Price        int32
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Finishdate   sql.NullTime
	Finishpic    sql.NullString
}

func (q *Queries) GetAllClaimedJobs(ctx context.Context, arg GetAllClaimedJobsParams) ([]GetAllClaimedJobsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllClaimedJobs,
		arg.Uid,
		arg.Jobid,
		arg.CmpID,
		arg.CjID,
		arg.Cat,
		arg.Ym,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllClaimedJobsRow
	for rows.Next() {
		var i GetAllClaimedJobsRow
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Userid,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.Price,
			&i.CreateDate,
			&i.Username,
			&i.Cmpname,
			&i.Cmpid,
			&i.Approveddate,
			&i.Finishdate,
			&i.Finishpic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCmp = `-- name: GetAllCmp :many
SELECT id, name, create_date, deleted_date, last_modified_date
from cmpt
`

func (q *Queries) GetAllCmp(ctx context.Context) ([]Cmpt, error) {
	rows, err := q.db.QueryContext(ctx, getAllCmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cmpt
	for rows.Next() {
		var i Cmpt
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsAdmin = `-- name: GetAllJobsAdmin :many
SELECT jobst.id, fromloc, mid, toloc, price, estimated, remaining, belongcmp, source, memo, jobst.create_date, jobst.deleted_date, jobst.last_modified_date, cmpt.id, name, cmpt.create_date, cmpt.deleted_date, cmpt.last_modified_date,
  cmpt.name as cmpName
from JobsT
  inner join cmpt on JobsT.belongcmp = cmpt.id
where (
    JobsT.id = $1
    OR $1 IS NULL
  )
  AND (
    JobsT.fromLoc = $2
    OR $2 IS NULL
  )
  AND (
    JobsT.Mid = $3
    OR $3 IS NULL
  )
  AND (
    JobsT.toLoc = $4
    OR $4 IS NULL
  )
  AND (
    belongcmp = $5
    OR $5 IS NULL
  )
  AND (remaining <> 0)
  AND (
    remaining <> $6
    OR $6 IS NULL
  )
  AND (
    (
      JobsT.create_date > $7
      OR $7 IS NULL
    )
    AND (
      JobsT.create_date < $8
      OR $8 IS NULL
    )
  )
  AND (
    (
      JobsT.last_modified_date > $9
      OR $9 IS NULL
    )
    AND (
      JobsT.last_modified_date < $10
      OR $10 IS NULL
    )
  )
  AND(JobsT.deleted_date is NULL)
`

type GetAllJobsAdminParams struct {
	ID                    sql.NullInt64
	FromLoc               sql.NullString
	Mid                   sql.NullString
	ToLoc                 sql.NullString
	Belongcmp             sql.NullInt64
	Remaining             sql.NullInt32
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetAllJobsAdminRow struct {
	ID                 int64
	Fromloc            string
	Mid                sql.NullString
	Toloc              string
	Price              int32
	Estimated          int32
	Remaining          int32
	Belongcmp          int64
	Source             string
	Memo               sql.NullString
	CreateDate         time.Time
	DeletedDate        sql.NullTime
	LastModifiedDate   time.Time
	ID_2               int64
	Name               string
	CreateDate_2       time.Time
	DeletedDate_2      sql.NullTime
	LastModifiedDate_2 time.Time
	Cmpname            string
}

func (q *Queries) GetAllJobsAdmin(ctx context.Context, arg GetAllJobsAdminParams) ([]GetAllJobsAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsAdmin,
		arg.ID,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Belongcmp,
		arg.Remaining,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsAdminRow
	for rows.Next() {
		var i GetAllJobsAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Memo,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
			&i.ID_2,
			&i.Name,
			&i.CreateDate_2,
			&i.DeletedDate_2,
			&i.LastModifiedDate_2,
			&i.Cmpname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsByCmp = `-- name: GetAllJobsByCmp :many
SELECT id, fromloc, mid, toloc, price, estimated, remaining, belongcmp, source, memo, create_date, deleted_date, last_modified_date
from JobsT
where belongcmp = $1
`

func (q *Queries) GetAllJobsByCmp(ctx context.Context, belongcmp int64) ([]Jobst, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobst
	for rows.Next() {
		var i Jobst
		if err := rows.Scan(
			&i.ID,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Memo,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsClient = `-- name: GetAllJobsClient :many
SELECT JobsT.ID,
  JobsT.fromLoc,
  JobsT.Mid,
  JobsT.toLoc,
  JobsT.Price,
  JobsT.Remaining,
  JobsT.Belongcmp,
  JobsT.Source,
  JobsT.Memo,
  -- JobsT.Close_Date,
  JobsT.deleted_date
from JobsT
  inner join cmpt on JobsT.belongcmp = cmpt.id
where (
    JobsT.id = $1
    OR $1 IS NULL
  )
  AND (
    JobsT.fromLoc = $2
    OR $2 IS NULL
  )
  AND (
    JobsT.Mid = $3
    OR $3 IS NULL
  )
  AND (
    JobsT.toLoc = $4
    OR $4 IS NULL
  )
  AND (
    belongcmp = $5
    OR $5 IS NULL
  )
  AND (remaining <> 0)
  AND (JobsT.deleted_date is NULL)
`

type GetAllJobsClientParams struct {
	ID        sql.NullInt64
	FromLoc   sql.NullString
	Mid       sql.NullString
	ToLoc     sql.NullString
	Belongcmp sql.NullInt64
}

type GetAllJobsClientRow struct {
	ID          int64
	Fromloc     string
	Mid         sql.NullString
	Toloc       string
	Price       int32
	Remaining   int32
	Belongcmp   int64
	Source      string
	Memo        sql.NullString
	DeletedDate sql.NullTime
}

func (q *Queries) GetAllJobsClient(ctx context.Context, arg GetAllJobsClientParams) ([]GetAllJobsClientRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsClient,
		arg.ID,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Belongcmp,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsClientRow
	for rows.Next() {
		var i GetAllJobsClientRow
		if err := rows.Scan(
			&i.ID,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.Price,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Memo,
			&i.DeletedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsSuper = `-- name: GetAllJobsSuper :many
SELECT cmpt.name AS cmpName,
  cmpt.id AS BELONGCMP,
  json_agg(
    json_build_object(
      'ID',
      JobsT.id,
      'Fromloc',
      JobsT.fromLoc,
      'Toloc',
      JobsT.toLoc,
      'Mid',
      JobsT.mid,
      'Price',
      JobsT.price,
      'estimated',
      JobsT.estimated,
      'Remaining',
      JobsT.remaining,
      'Source',
      JobsT.source,
      'Memo',
      JobsT.memo,
      'Belongcmp',
      cmpT.id,
      'create_date',
      JobsT.create_date
    )
  ) AS jobs
FROM JobsT
  INNER JOIN cmpt ON JobsT.belongcmp = cmpt.id
where (
    JobsT.id = $1
    OR $1 IS NULL
  )
  AND (
    JobsT.fromLoc = $2
    OR $2 IS NULL
  )
  AND (
    JobsT.Mid = $3
    OR $3 IS NULL
  )
  AND (
    JobsT.toLoc = $4
    OR $4 IS NULL
  )
  AND (
    belongcmp = $5
    OR $5 IS NULL
  )
  AND (remaining <> 0)
  AND (
    remaining <> $6
    OR $6 IS NULL
  )
  AND (
    (
      JobsT.create_date > $7
      OR $7 IS NULL
    )
    AND (
      JobsT.create_date < $8
      OR $8 IS NULL
    )
  )
  AND (
    (
      JobsT.last_modified_date > $9
      OR $9 IS NULL
    )
    AND (
      JobsT.last_modified_date < $10
      OR $10 IS NULL
    )
  )
  AND(JobsT.deleted_date is NULL)
GROUP BY cmpt.name,
  cmpt.id
`

type GetAllJobsSuperParams struct {
	ID                    sql.NullInt64
	FromLoc               sql.NullString
	Mid                   sql.NullString
	ToLoc                 sql.NullString
	Belongcmp             sql.NullInt64
	Remaining             sql.NullInt32
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetAllJobsSuperRow struct {
	Cmpname   string
	Belongcmp int64
	Jobs      json.RawMessage
}

func (q *Queries) GetAllJobsSuper(ctx context.Context, arg GetAllJobsSuperParams) ([]GetAllJobsSuperRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsSuper,
		arg.ID,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Belongcmp,
		arg.Remaining,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllJobsSuperRow
	for rows.Next() {
		var i GetAllJobsSuperRow
		if err := rows.Scan(&i.Cmpname, &i.Belongcmp, &i.Jobs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserFromCMP = `-- name: GetAllUserFromCMP :many
SELECT usert.id,
  usert.name
from userT
where belongCMP = $1
`

type GetAllUserFromCMPRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetAllUserFromCMP(ctx context.Context, belongcmp int64) ([]GetAllUserFromCMPRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserFromCMP, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserFromCMPRow
	for rows.Next() {
		var i GetAllUserFromCMPRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCJDate = `-- name: GetCJDate :many
SELECT to_char(create_date, 'YYYY-MM')
FROM public.claimjobt
where driverid = $1
group by to_char(create_date, 'YYYY-MM')
`

func (q *Queries) GetCJDate(ctx context.Context, driverid int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCJDate, driverid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var to_char string
		if err := rows.Scan(&to_char); err != nil {
			return nil, err
		}
		items = append(items, to_char)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByCmp = `-- name: GetClaimedJobByCmp :many
SELECT ClaimJobT.id as id,
  JobsT.id as JobID,
  UserT.id as UserID,
  JobsT.fromLoc,
  JobsT.mid,
  JobsT.toLoc,
  ClaimJobT.Create_Date,
  usert.name as userName,
  cmpt.name as cmpname,
  cmpT.id as cmpID,
  ClaimJobT.Approved_date as ApprovedDate,
  ClaimJobT.Finished_Date as FinishDate
from ClaimJobT
  inner join JobsT on JobsT.id = ClaimJobT.JobId
  inner join UserT on UserT.id = ClaimJobT.Driverid
  inner join Cmpt on UserT.belongCMP = cmpt.id
WHERE ClaimJobT.Deleted_date is null
  and UserT.belongCMP = $1
  and ClaimJobT.Approved_date between $2 and $3
`

type GetClaimedJobByCmpParams struct {
	Belongcmp      int64
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
}

type GetClaimedJobByCmpRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	Fromloc      string
	Mid          sql.NullString
	Toloc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Finishdate   sql.NullTime
}

func (q *Queries) GetClaimedJobByCmp(ctx context.Context, arg GetClaimedJobByCmpParams) ([]GetClaimedJobByCmpRow, error) {
	rows, err := q.db.QueryContext(ctx, getClaimedJobByCmp, arg.Belongcmp, arg.ApprovedDate, arg.ApprovedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClaimedJobByCmpRow
	for rows.Next() {
		var i GetClaimedJobByCmpRow
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Userid,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.CreateDate,
			&i.Username,
			&i.Cmpname,
			&i.Cmpid,
			&i.Approveddate,
			&i.Finishdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByDriverID = `-- name: GetClaimedJobByDriverID :many
SELECT ClaimJobT.id as id,
  JobsT.id as JobID,
  UserT.id as UserID,
  JobsT.fromLoc,
  JobsT.mid,
  JobsT.toLoc,
  ClaimJobT.Create_Date,
  usert.name as userName,
  cmpt.name as cmpname,
  cmpT.id as cmpID,
  ClaimJobT.Approved_date as ApprovedDate,
  ClaimJobT.Finished_Date as FinishDate
from ClaimJobT
  inner join JobsT on JobsT.id = ClaimJobT.JobId
  inner join UserT on UserT.id = ClaimJobT.Driverid
  inner join Cmpt on UserT.belongCMP = cmpt.id
WHERE ClaimJobT.Deleted_date is null
  and UserT.id = $1
  and ClaimJobT.Approved_date between $2 and $3
`

type GetClaimedJobByDriverIDParams struct {
	ID             int64
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
}

type GetClaimedJobByDriverIDRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	Fromloc      string
	Mid          sql.NullString
	Toloc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Finishdate   sql.NullTime
}

func (q *Queries) GetClaimedJobByDriverID(ctx context.Context, arg GetClaimedJobByDriverIDParams) ([]GetClaimedJobByDriverIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getClaimedJobByDriverID, arg.ID, arg.ApprovedDate, arg.ApprovedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClaimedJobByDriverIDRow
	for rows.Next() {
		var i GetClaimedJobByDriverIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Userid,
			&i.Fromloc,
			&i.Mid,
			&i.Toloc,
			&i.CreateDate,
			&i.Username,
			&i.Cmpname,
			&i.Cmpid,
			&i.Approveddate,
			&i.Finishdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByID = `-- name: GetClaimedJobByID :one
SELECT ClaimJobT.id as id,
  JobsT.id as JobID,
  UserT.id as UserID,
  JobsT.fromLoc,
  finished_date,
  finishPic,
  JobsT.mid,
  JobsT.toLoc,
  ClaimJobT.Create_Date,
  usert.name as userName,
  cmpt.name as cmpname,
  cmpT.id as cmpID,
  ClaimJobT.Approved_date as ApprovedDate,
  price
from ClaimJobT
  inner join JobsT on JobsT.id = ClaimJobT.JobId
  inner join UserT on UserT.id = ClaimJobT.Driverid
  inner join Cmpt on UserT.belongCMP = cmpt.id
  inner join DriverT on driverT.id = UserT.id
WHERE ClaimJobT.id = $1
`

type GetClaimedJobByIDRow struct {
	ID           int64
	Jobid        int64
	Userid       int64
	Fromloc      string
	FinishedDate sql.NullTime
	Finishpic    sql.NullString
	Mid          sql.NullString
	Toloc        string
	CreateDate   time.Time
	Username     string
	Cmpname      string
	Cmpid        int64
	Approveddate sql.NullTime
	Price        int32
}

func (q *Queries) GetClaimedJobByID(ctx context.Context, id int64) (GetClaimedJobByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getClaimedJobByID, id)
	var i GetClaimedJobByIDRow
	err := row.Scan(
		&i.ID,
		&i.Jobid,
		&i.Userid,
		&i.Fromloc,
		&i.FinishedDate,
		&i.Finishpic,
		&i.Mid,
		&i.Toloc,
		&i.CreateDate,
		&i.Username,
		&i.Cmpname,
		&i.Cmpid,
		&i.Approveddate,
		&i.Price,
	)
	return i, err
}

const getCmp = `-- name: GetCmp :one
SELECT cmpt.id, cmpt.name, cmpt.create_date, cmpt.deleted_date, cmpt.last_modified_date, usert.id, phonenum, phonenumind, pwd, usert.name, belongcmp, seed, role, initpwdchanged, usert.create_date, usert.deleted_date, usert.last_modified_date
FROM cmpt
  inner join usert on cmpt.id = usert.belongcmp
  AND (
    usert.role = 200
    OR usert.role = 100
  )
where cmpt.id = $1
`

type GetCmpRow struct {
	ID                 int64
	Name               string
	CreateDate         time.Time
	DeletedDate        sql.NullTime
	LastModifiedDate   time.Time
	ID_2               int64
	Phonenum           interface{}
	Phonenumind        interface{}
	Pwd                string
	Name_2             string
	Belongcmp          int64
	Seed               sql.NullString
	Role               int16
	Initpwdchanged     bool
	CreateDate_2       time.Time
	DeletedDate_2      sql.NullTime
	LastModifiedDate_2 time.Time
}

func (q *Queries) GetCmp(ctx context.Context, id int64) (GetCmpRow, error) {
	row := q.db.QueryRowContext(ctx, getCmp, id)
	var i GetCmpRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
		&i.ID_2,
		&i.Phonenum,
		&i.Phonenumind,
		&i.Pwd,
		&i.Name_2,
		&i.Belongcmp,
		&i.Seed,
		&i.Role,
		&i.Initpwdchanged,
		&i.CreateDate_2,
		&i.DeletedDate_2,
		&i.LastModifiedDate_2,
	)
	return i, err
}

const getCurrentClaimedJob = `-- name: GetCurrentClaimedJob :one
SELECT t2.id as claimID,
  t2.create_date as claimDate,
  t1.fromLoc,
  t1.mid,
  t1.toLoc,
  t1.price,
  t1.source,
  t1.memo,
  t1.id
FROM ClaimJobT t2
  inner join JobsT t1 on t1.id = t2.jobID
where t2.driverID = $1
  and (
    t2.deleted_date IS NULL
    and t2.finished_date IS NULL
  )
order by t2.create_date
LIMIT 1
`

type GetCurrentClaimedJobRow struct {
	Claimid   int64
	Claimdate time.Time
	Fromloc   string
	Mid       sql.NullString
	Toloc     string
	Price     int32
	Source    string
	Memo      sql.NullString
	ID        int64
}

func (q *Queries) GetCurrentClaimedJob(ctx context.Context, driverid int64) (GetCurrentClaimedJobRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentClaimedJob, driverid)
	var i GetCurrentClaimedJobRow
	err := row.Scan(
		&i.Claimid,
		&i.Claimdate,
		&i.Fromloc,
		&i.Mid,
		&i.Toloc,
		&i.Price,
		&i.Source,
		&i.Memo,
		&i.ID,
	)
	return i, err
}

const getDriver = `-- name: GetDriver :one
SELECT UserT.id as ID,
  insurances,
  registration,
  driverLicense,
  TruckLicense,
  nationalidnumber,
  cmpt.name as cmpName,
  usert.phoneNum,
  usert.name as userName,
  usert.belongCMP,
  usert.role,
  usert.initPwdChanged,
  DriverT.lastAlert,
  DriverT.Approved_date,
  UserT.Deleted_Date as Deleted_Date
FROM DriverT
  inner join usert on DriverT.id = UserT.id
  inner join cmpt on usert.belongCMP = cmpt.id
where DriverT.id = $1
LIMIT 1
`

type GetDriverRow struct {
	ID               int64
	Insurances       sql.NullString
	Registration     sql.NullString
	Driverlicense    sql.NullString
	Trucklicense     sql.NullString
	Nationalidnumber interface{}
	Cmpname          string
	Phonenum         interface{}
	Username         string
	Belongcmp        int64
	Role             int16
	Initpwdchanged   bool
	Lastalert        sql.NullInt64
	ApprovedDate     sql.NullTime
	DeletedDate      sql.NullTime
}

func (q *Queries) GetDriver(ctx context.Context, id int64) (GetDriverRow, error) {
	row := q.db.QueryRowContext(ctx, getDriver, id)
	var i GetDriverRow
	err := row.Scan(
		&i.ID,
		&i.Insurances,
		&i.Registration,
		&i.Driverlicense,
		&i.Trucklicense,
		&i.Nationalidnumber,
		&i.Cmpname,
		&i.Phonenum,
		&i.Username,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.Lastalert,
		&i.ApprovedDate,
		&i.DeletedDate,
	)
	return i, err
}

const getDriverRevenue = `-- name: GetDriverRevenue :many
SELECT coalesce(sum(t2.PRICE), 0) as earn,
  coalesce(count(t2.ID), 0) as count
from ClaimJobT t1
  inner join JobsT t2 on t1.jobID = t2.id
where t1.driverID = $1
  and (
    t1.finished_date IS NOT NULL
    and approved_date IS NOT NULL
    and t1.deleted_date IS NULL
  )
  and date(t1.finished_date) >= date($2)
  and date(t1.finished_date) <= date($3)
`

type GetDriverRevenueParams struct {
	Driverid int64
	Date     interface{}
	Date_2   interface{}
}

type GetDriverRevenueRow struct {
	Earn  interface{}
	Count interface{}
}

func (q *Queries) GetDriverRevenue(ctx context.Context, arg GetDriverRevenueParams) ([]GetDriverRevenueRow, error) {
	rows, err := q.db.QueryContext(ctx, getDriverRevenue, arg.Driverid, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriverRevenueRow
	for rows.Next() {
		var i GetDriverRevenueRow
		if err := rows.Scan(&i.Earn, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriverRevenueByCmp = `-- name: GetDriverRevenueByCmp :many
SELECT coalesce(sum(t2.PRICE), 0) as earn,
  coalesce(count(t2.ID), 0) as count
from ClaimJobT t1
  inner join JobsT t2 on t1.jobID = t2.id
  inner join UserT t3 on t1.driverID = t3.id
where t3.belongCMP = $1
  and (
    t1.finished_date IS NOT NULL
    and approved_date IS NOT NULL
    and t1.deleted_date IS NULL
  )
  and date(t1.finished_date) >= date($2)
  and date(t1.finished_date) <= date($3)
`

type GetDriverRevenueByCmpParams struct {
	Belongcmp int64
	Date      interface{}
	Date_2    interface{}
}

type GetDriverRevenueByCmpRow struct {
	Earn  interface{}
	Count interface{}
}

func (q *Queries) GetDriverRevenueByCmp(ctx context.Context, arg GetDriverRevenueByCmpParams) ([]GetDriverRevenueByCmpRow, error) {
	rows, err := q.db.QueryContext(ctx, getDriverRevenueByCmp, arg.Belongcmp, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriverRevenueByCmpRow
	for rows.Next() {
		var i GetDriverRevenueByCmpRow
		if err := rows.Scan(&i.Earn, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGas = `-- name: GetGas :many
SELECT gasT.id as ID,
  UserT.id as Driverid,
  UserT.Name as Drivername,
  cmpt.name as cmpName,
  cmpt.id as cmpID,
  -- Include repair information as JSON with default values if NULL

  COALESCE(
    (
      SELECT jsonb_agg(
        jsonb_build_object(
          'id', COALESCE(GasInfoT.id, 0),
          'itemName', COALESCE(GasInfoT.itemName, ''),
          'quantity', COALESCE(GasInfoT.quantity, 0),
          'totalPrice', COALESCE(GasInfoT.totalPrice, 0),
          'create_date', COALESCE(GasInfoT.create_date, '1970-01-01')
        )
      )
      FROM GasInfoT
      WHERE GasInfoT.gasID = gasT.id
    ), '[
        {
          "id": 0,
          "itemName": "",
          "quantity": 0,
          "totalPrice": 0,
          "create_date": "1970-01-01"
        }
      ]'::jsonb
  ) AS Repairinfo,
  gasT.Create_Date as CreateDate,
  gasT.Approved_Date as ApprovedDate,
  gasT.pic as pic,
  driverT.plateNum as plateNum
FROM gasT
  INNER JOIN UserT ON UserT.id = gasT.driverID
  INNER JOIN driverT ON UserT.id = driverT.id
  INNER JOIN cmpt ON cmpt.id = UserT.belongCMP
WHERE  (
    gasT.id = $1
    OR $1 IS NULL
  )
  AND (
    gasT.driverID = $2
    OR $2 IS NULL
  )
  AND (
    UserT.name = $3
    OR $3 IS NULL
  )
  AND (
    UserT.belongcmp = $4
    OR $4 IS NULL
  )
  AND gasT.deleted_date IS NULL
  AND (
    (
      $5 = 'pending'
      AND gasT.Approved_date IS NULL
    )
    OR ($5 IS NULL)
  )
  AND (
    to_char(date(gasT.create_date), 'YYYY-MM') = to_char(date($6), 'YYYY-MM')
    OR $6 IS NULL
  )
`

type GetGasParams struct {
	ID        sql.NullInt64
	DriverID  sql.NullInt64
	Name      sql.NullString
	Belongcmp sql.NullInt64
	Cat       interface{}
	Ym        interface{}
}

type GetGasRow struct {
	ID           int64
	Driverid     int64
	Drivername   string
	Cmpname      string
	Cmpid        int64
	Repairinfo   interface{}
	Createdate   time.Time
	Approveddate sql.NullTime
	Pic          sql.NullString
	Platenum     string
}

func (q *Queries) GetGas(ctx context.Context, arg GetGasParams) ([]GetGasRow, error) {
	rows, err := q.db.QueryContext(ctx, getGas,
		arg.ID,
		arg.DriverID,
		arg.Name,
		arg.Belongcmp,
		arg.Cat,
		arg.Ym,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGasRow
	for rows.Next() {
		var i GetGasRow
		if err := rows.Scan(
			&i.ID,
			&i.Driverid,
			&i.Drivername,
			&i.Cmpname,
			&i.Cmpid,
			&i.Repairinfo,
			&i.Createdate,
			&i.Approveddate,
			&i.Pic,
			&i.Platenum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGasCmpUser = `-- name: GetGasCmpUser :many
SELECT JSON_BUILD_OBJECT(
    'cmpName',
    cmpt.name,
    'cmpId',
    cmpt.id,
    'users',
    JSON_AGG(
      JSON_BUILD_OBJECT(
        'driverID',
        UserT.id,
        'driverName',
        UserT.name
      )
    )
  ) AS result
FROM cmpt
  INNER JOIN (
    SELECT DISTINCT ON (UserT.id) UserT.id,
      UserT.name,
      UserT.belongCMP
    FROM GasT
      INNER JOIN UserT ON UserT.id = GasT.driverID
      INNER JOIN driverT ON UserT.id = driverT.id
    WHERE GasT.deleted_date IS NULL
      AND ((GasT.Approved_date IS NULL))
  ) AS UserT ON UserT.belongCMP = cmpt.id
WHERE (
    UserT.belongCMP = $1
    OR $1 IS NULL
  )
GROUP BY cmpt.name,
  cmpt.id
`

func (q *Queries) GetGasCmpUser(ctx context.Context, belongcmp sql.NullInt64) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getGasCmpUser, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var result json.RawMessage
		if err := rows.Scan(&result); err != nil {
			return nil, err
		}
		items = append(items, result)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGasDate = `-- name: GetGasDate :many
SELECT to_char(create_date, 'YYYY-MM')
FROM public.GasT
where driverid = $1
group by to_char(create_date, 'YYYY-MM')
`

func (q *Queries) GetGasDate(ctx context.Context, driverid int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getGasDate, driverid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var to_char string
		if err := rows.Scan(&to_char); err != nil {
			return nil, err
		}
		items = append(items, to_char)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGasInfoById = `-- name: GetGasInfoById :many
SELECT id, gasid, itemname, quantity, totalprice, create_date, deleted_date, last_modified_date
from GasInfoT
where gasID = $1
`

func (q *Queries) GetGasInfoById(ctx context.Context, gasid int64) ([]Gasinfot, error) {
	rows, err := q.db.QueryContext(ctx, getGasInfoById, gasid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Gasinfot
	for rows.Next() {
		var i Gasinfot
		if err := rows.Scan(
			&i.ID,
			&i.Gasid,
			&i.Itemname,
			&i.Quantity,
			&i.Totalprice,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobById = `-- name: GetJobById :one
SELECT id, fromloc, mid, toloc, price, estimated, remaining, belongcmp, source, memo, create_date, deleted_date, last_modified_date
from JobsT
where id = $1
LIMIT 1
`

func (q *Queries) GetJobById(ctx context.Context, id int64) (Jobst, error) {
	row := q.db.QueryRowContext(ctx, getJobById, id)
	var i Jobst
	err := row.Scan(
		&i.ID,
		&i.Fromloc,
		&i.Mid,
		&i.Toloc,
		&i.Price,
		&i.Estimated,
		&i.Remaining,
		&i.Belongcmp,
		&i.Source,
		&i.Memo,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getJobCmp = `-- name: GetJobCmp :many
WITH user_jobs AS (
  SELECT UserT.id AS UserID,
    UserT.name AS UserName,
    Cmpt.id AS CmpID,
    Cmpt.name AS CmpName,
    ClaimJobT.id AS ID,
    JobsT.id AS JobID,
    JobsT.fromLoc AS FromLoc,
    JobsT.mid AS Mid,
    JobsT.toLoc AS ToLoc,
    ClaimJobT.Create_Date AS CreateDate,
    ClaimJobT.Approved_date AS ApprovedDate,
    ClaimJobT.Finished_Date AS FinishDate,
    JobsT.price AS JobPrice
  FROM ClaimJobT
    INNER JOIN JobsT ON JobsT.id = ClaimJobT.JobID
    INNER JOIN UserT ON UserT.id = ClaimJobT.DriverID
    INNER JOIN Cmpt ON UserT.belongCMP = Cmpt.id
  WHERE ClaimJobT.Deleted_date IS NULL
    AND ClaimJobT.Approved_date BETWEEN $1 AND $2
    AND (
      Cmpt.id = $3
      OR $3 IS NULL
    )
    AND (
      UserT.id = $4
      OR $4 IS NULL
    )
),
user_gas AS (
  SELECT UserT.id AS UserID,
    UserT.name AS UserName,
    Cmpt.id AS CmpID,
    Cmpt.name AS CmpName,
    SUM(GasInfoT.totalPrice) AS GasTotal
  FROM GasT
    INNER JOIN GasInfoT ON GasInfoT.gasID = GasT.id
    INNER JOIN UserT ON UserT.id = GasT.DriverID
    INNER JOIN Cmpt ON UserT.belongCMP = Cmpt.id
  WHERE GasT.Deleted_date IS NULL
    AND GasT.approved_date BETWEEN $1 AND $2
    AND (
      Cmpt.id = $3
      OR $3 IS NULL
    )
    AND (
      UserT.id = $4
      OR $4 IS NULL
    )
  GROUP BY UserT.id,
    UserT.name,
    Cmpt.id,
    Cmpt.name
),
user_repair AS (
  SELECT UserT.id AS UserID,
    UserT.name AS UserName,
    Cmpt.id AS CmpID,
    Cmpt.name AS CmpName,
    SUM(RepairInfoT.totalPrice) AS RepairTotal
  FROM RepairT
    INNER JOIN RepairInfoT ON RepairInfoT.repairID = RepairT.id
    INNER JOIN UserT ON UserT.id = RepairT.DriverID
    INNER JOIN Cmpt ON UserT.belongCMP = Cmpt.id
  WHERE RepairT.Deleted_date IS NULL
    AND RepairT.approved_date BETWEEN $1 AND $2
    AND (
      Cmpt.id = $3
      OR $3 IS NULL
    )
    AND (
      UserT.id = $4
      OR $4 IS NULL
    )
  GROUP BY UserT.id,
    UserT.name,
    Cmpt.id,
    Cmpt.name
),
user_summary AS (
  SELECT uj.CmpID,
    uj.CmpName,
    uj.UserID,
    uj.UserName,
    COUNT(uj.ID) AS JobCount,
    SUM(uj.JobPrice) AS JobTotal,
    COALESCE(ug.GasTotal, 0) AS GasTotal,
    COALESCE(ur.RepairTotal, 0) AS RepairTotal
  FROM user_jobs uj
    LEFT JOIN user_gas ug ON uj.UserID = ug.UserID
    LEFT JOIN user_repair ur ON uj.UserID = ur.UserID
  GROUP BY uj.CmpID,
    uj.CmpName,
    uj.UserID,
    uj.UserName,
    ug.GasTotal,
    ur.RepairTotal
)
SELECT cmpt.CmpID AS ID,
  cmpt.CmpName AS Name,
  SUM(cmpt.JobCount) AS Count,
  SUM(cmpt.JobTotal) AS JobTotal,
  SUM(cmpt.GasTotal) AS GasTotal,
  SUM(cmpt.RepairTotal) AS RepairTotal,
  JSON_AGG(
    JSON_BUILD_OBJECT(
      'UserID',
      cmpt.UserID,
      'UserName',
      cmpt.UserName,
      'JobCount',
      cmpt.JobCount,
      'JobTotal',
      cmpt.JobTotal,
      'GasTotal',
      cmpt.GasTotal,
      'RepairTotal',
      cmpt.RepairTotal
    )
  ) AS Users
FROM (
    SELECT CmpID,
      CmpName,
      UserID,
      UserName,
      JobCount,
      JobTotal,
      GasTotal,
      RepairTotal
    FROM user_summary
  ) AS cmpt
GROUP BY cmpt.CmpID,
  cmpt.CmpName
`

type GetJobCmpParams struct {
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
	CmpId          sql.NullInt64
	UserId         sql.NullInt64
}

type GetJobCmpRow struct {
	ID          int64
	Name        string
	Count       int64
	Jobtotal    int64
	Gastotal    int64
	Repairtotal int64
	Users       json.RawMessage
}

func (q *Queries) GetJobCmp(ctx context.Context, arg GetJobCmpParams) ([]GetJobCmpRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobCmp,
		arg.ApprovedDate,
		arg.ApprovedDate_2,
		arg.CmpId,
		arg.UserId,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobCmpRow
	for rows.Next() {
		var i GetJobCmpRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Count,
			&i.Jobtotal,
			&i.Gastotal,
			&i.Repairtotal,
			&i.Users,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobCmpX = `-- name: GetJobCmpX :many
WITH user_jobs AS (
  SELECT UserT.id AS Userid,
    UserT.name AS Username,
    cmpt.id AS Cmpid,
    cmpt.name AS Cmpname,
    ClaimJobT.id AS ID,
    JobsT.id AS Jobid,
    JobsT.fromLoc AS Fromloc,
    JobsT.mid AS Mid,
    JobsT.toLoc AS Toloc,
    ClaimJobT.Create_Date AS CreateDate,
    ClaimJobT.Approved_date AS Approveddate,
    ClaimJobT.Finished_Date AS Finishdate,
    JobsT.price
  FROM ClaimJobT
    INNER JOIN JobsT ON JobsT.id = ClaimJobT.JobId
    INNER JOIN UserT ON UserT.id = ClaimJobT.Driverid
    INNER JOIN Cmpt ON UserT.belongCMP = Cmpt.id
  WHERE ClaimJobT.Deleted_date IS NULL
    AND ClaimJobT.Approved_date BETWEEN $1 AND $2
    AND (
      cmpt.id = $3
      OR $3 IS NULL
    )
)
SELECT cmpt.cmpID AS ID,
  cmpt.cmpName AS Name,
  SUM(cmpt.jobCount) AS count,
  -- Summing the job count from the inner query
  SUM(cmpt.price) AS total,
  JSON_AGG(
    JSON_BUILD_OBJECT(
      'UserID',
      cmpt.UserID,
      'UserName',
      cmpt.UserName,
      'job',
      jobsList
    )
  ) AS jobs
FROM (
    SELECT cmpID,
      cmpName,
      UserID,
      UserName,
      COUNT(*) AS jobCount,
      -- Count the jobs per user in the inner query
      JSON_AGG(
        JSON_BUILD_OBJECT(
          'ID',
          ID,
          'Username',
          UserName,
          'Jobid',
          JobID,
          'Fromloc',
          Fromloc,
          'Mid',
          Mid,
          'Toloc',
          Toloc,
          'CreateDate',
          CreateDate,
          'Approveddate',
          Approveddate,
          'Finishdate',
          Finishdate
        )
      ) AS jobsList,
      SUM(price) AS price
    FROM user_jobs
    GROUP BY cmpID,
      cmpName,
      UserID,
      UserName
  ) AS cmpt
GROUP BY cmpt.cmpID,
  cmpt.cmpName
`

type GetJobCmpXParams struct {
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
	CmpId          sql.NullInt64
}

type GetJobCmpXRow struct {
	ID    int64
	Name  string
	Count int64
	Total int64
	Jobs  json.RawMessage
}

func (q *Queries) GetJobCmpX(ctx context.Context, arg GetJobCmpXParams) ([]GetJobCmpXRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobCmpX, arg.ApprovedDate, arg.ApprovedDate_2, arg.CmpId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobCmpXRow
	for rows.Next() {
		var i GetJobCmpXRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Count,
			&i.Total,
			&i.Jobs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobCmpXX = `-- name: GetJobCmpXX :many
SELECT cmpt.id AS cmpID,
  cmpt.name AS cmpName,
  COUNT(*) AS jobCount,
  SUM(JobsT.price) AS totalAmount,
  JSON_AGG(
    JSON_BUILD_OBJECT(
      'userID',
      UserT.id,
      'userName',
      UserT.name,
      'jobs',
      (
        SELECT JSON_AGG(
            JSON_BUILD_OBJECT(
              'id',
              ClaimJobT.id,
              'jobID',
              JobsT.id,
              'fromLoc',
              JobsT.fromLoc,
              'mid',
              JobsT.mid,
              'toLoc',
              JobsT.toLoc,
              'createDate',
              ClaimJobT.Create_Date,
              'approvedDate',
              ClaimJobT.Approved_date,
              'finishDate',
              ClaimJobT.Finished_Date
            )
          )
        FROM ClaimJobT AS innerClaim
        WHERE innerClaim.DriverID = UserT.id
          AND innerClaim.Deleted_date IS NULL
          AND innerClaim.Approved_date BETWEEN $1 AND $2
      )
    )
  ) AS users
FROM ClaimJobT
  INNER JOIN JobsT ON JobsT.id = ClaimJobT.JobId
  INNER JOIN UserT ON UserT.id = ClaimJobT.Driverid
  INNER JOIN Cmpt ON UserT.belongCMP = Cmpt.id
WHERE ClaimJobT.Deleted_date IS NULL
  AND (
    cmpt.id = $3
    OR $3 IS NULL
  )
  AND ClaimJobT.Approved_date BETWEEN $1 AND $2
GROUP BY cmpt.id,
  cmpt.name
`

type GetJobCmpXXParams struct {
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
	CmpId          sql.NullInt64
}

type GetJobCmpXXRow struct {
	Cmpid       int64
	Cmpname     string
	Jobcount    int64
	Totalamount int64
	Users       json.RawMessage
}

func (q *Queries) GetJobCmpXX(ctx context.Context, arg GetJobCmpXXParams) ([]GetJobCmpXXRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobCmpXX, arg.ApprovedDate, arg.ApprovedDate_2, arg.CmpId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobCmpXXRow
	for rows.Next() {
		var i GetJobCmpXXRow
		if err := rows.Scan(
			&i.Cmpid,
			&i.Cmpname,
			&i.Jobcount,
			&i.Totalamount,
			&i.Users,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobCmpXXX = `-- name: GetJobCmpXXX :many
SELECT cmpt.id,
  cmpt.name,
  COUNT(*) as count,
  sum(price) as total
FROM cmpt
  LEFT JOIN userT ON userT.belongCMP = cmpt.id
  LEFT JOIN claimjobt ON claimjobt.driverID = userT.id
  LEFT JOIN JobsT on claimjobt.jobID = JobsT.id
WHERE claimjobt.Approved_date BETWEEN $1 AND $2
  AND (
    cmpt.id = $3
    OR $3 IS NULL
  )
GROUP BY cmpt.id,
  cmpt.name
`

type GetJobCmpXXXParams struct {
	ApprovedDate   sql.NullTime
	ApprovedDate_2 sql.NullTime
	CmpId          sql.NullInt64
}

type GetJobCmpXXXRow struct {
	ID    int64
	Name  string
	Count int64
	Total int64
}

func (q *Queries) GetJobCmpXXX(ctx context.Context, arg GetJobCmpXXXParams) ([]GetJobCmpXXXRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobCmpXXX, arg.ApprovedDate, arg.ApprovedDate_2, arg.CmpId)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobCmpXXXRow
	for rows.Next() {
		var i GetJobCmpXXXRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Count,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastAlert = `-- name: GetLastAlert :one
SELECT lastAlert
from driverT
where id = $1
`

func (q *Queries) GetLastAlert(ctx context.Context, id int64) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, getLastAlert, id)
	var lastalert sql.NullInt64
	err := row.Scan(&lastalert)
	return lastalert, err
}

const getRepair = `-- name: GetRepair :many
SELECT repairT.id as ID,
  UserT.id as Driverid,
  UserT.Name as Drivername,
  cmpt.name as cmpName,
  cmpt.id as cmpID,
  -- Include repair information as JSON
  (
    SELECT json_agg(
        json_build_object(
          'id',
          repairinfoT.id,
          'itemName',
          repairinfoT.itemName,
          'quantity',
          repairinfoT.quantity,
          'totalPrice',
          repairinfoT.totalPrice,
          'create_date',
          repairinfoT.create_date
        )
      )
    FROM repairinfoT
    WHERE repairinfoT.repairID = repairT.id
  ) as Repairinfo,
  repairT.Create_Date as CreateDate,
  repairT.Approved_Date as ApprovedDate,
  repairT.pic as pic,
  repairT.place as place,
  driverT.plateNum as plateNum
FROM repairT
  INNER JOIN UserT ON UserT.id = repairT.driverID
  INNER JOIN driverT ON UserT.id = driverT.id
  INNER JOIN cmpt ON cmpt.id = UserT.belongCMP
WHERE (
    repairT.id = $1
    OR $1 IS NULL
  )
  AND (
    repairT.driverID = $2
    OR $2 IS NULL
  )
  AND (
    UserT.name = $3
    OR $3 IS NULL
  )
  AND (
    UserT.belongcmp = $4
    OR $4 IS NULL
  )
  AND repairT.deleted_date IS NULL
  AND (
    (
      $5 = 'pending'
      AND repairT.Approved_date IS NULL
    )
    OR ($5 IS NULL)
  )
  AND (
    to_char(date(repairT.create_date), 'YYYY-MM') = to_char(date($6), 'YYYY-MM')
    OR $6 IS NULL
  )
`

type GetRepairParams struct {
	ID        sql.NullInt64
	DriverID  sql.NullInt64
	Name      sql.NullString
	Belongcmp sql.NullInt64
	Cat       interface{}
	Ym        interface{}
}

type GetRepairRow struct {
	ID           int64
	Driverid     int64
	Drivername   string
	Cmpname      string
	Cmpid        int64
	Repairinfo   json.RawMessage
	Createdate   time.Time
	Approveddate sql.NullTime
	Pic          sql.NullString
	Place        string
	Platenum     string
}

func (q *Queries) GetRepair(ctx context.Context, arg GetRepairParams) ([]GetRepairRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepair,
		arg.ID,
		arg.DriverID,
		arg.Name,
		arg.Belongcmp,
		arg.Cat,
		arg.Ym,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepairRow
	for rows.Next() {
		var i GetRepairRow
		if err := rows.Scan(
			&i.ID,
			&i.Driverid,
			&i.Drivername,
			&i.Cmpname,
			&i.Cmpid,
			&i.Repairinfo,
			&i.Createdate,
			&i.Approveddate,
			&i.Pic,
			&i.Place,
			&i.Platenum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepairCmpUser = `-- name: GetRepairCmpUser :many
SELECT JSON_BUILD_OBJECT(
    'cmpName',
    cmpt.name,
    'cmpId',
    cmpt.id,
    'users',
    JSON_AGG(
      JSON_BUILD_OBJECT(
        'driverID',
        UserT.id,
        'driverName',
        UserT.name
      )
    )
  ) AS result
FROM cmpt
  INNER JOIN (
    SELECT DISTINCT ON (UserT.id) UserT.id,
      UserT.name,
      UserT.belongCMP
    FROM repairT
      INNER JOIN UserT ON UserT.id = repairT.driverID
      INNER JOIN driverT ON UserT.id = driverT.id
    WHERE repairT.deleted_date IS NULL
      AND ((repairT.Approved_date IS NULL))
  ) AS UserT ON UserT.belongCMP = cmpt.id
WHERE (
    UserT.belongCMP = $1
    OR $1 IS NULL
  )
GROUP BY cmpt.name,
  cmpt.id
`

func (q *Queries) GetRepairCmpUser(ctx context.Context, belongcmp sql.NullInt64) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getRepairCmpUser, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var result json.RawMessage
		if err := rows.Scan(&result); err != nil {
			return nil, err
		}
		items = append(items, result)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepairDate = `-- name: GetRepairDate :many
SELECT to_char(create_date, 'YYYY-MM')
FROM public.repairT
where driverid = $1
group by to_char(create_date, 'YYYY-MM')
`

func (q *Queries) GetRepairDate(ctx context.Context, driverid int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getRepairDate, driverid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var to_char string
		if err := rows.Scan(&to_char); err != nil {
			return nil, err
		}
		items = append(items, to_char)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepairInfoById = `-- name: GetRepairInfoById :many
SELECT id, repairid, itemname, quantity, totalprice, create_date, deleted_date, last_modified_date
from RepairInfoT
where repairID = $1
`

func (q *Queries) GetRepairInfoById(ctx context.Context, repairid int64) ([]Repairinfot, error) {
	rows, err := q.db.QueryContext(ctx, getRepairInfoById, repairid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repairinfot
	for rows.Next() {
		var i Repairinfot
		if err := rows.Scan(
			&i.ID,
			&i.Repairid,
			&i.Itemname,
			&i.Quantity,
			&i.Totalprice,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueExcel = `-- name: GetRevenueExcel :many
WITH GasData AS (
  SELECT GasT.DRIVERID,
    SUM(GasInfoT.totalPrice) AS GAS,
    DATE(GasT.Approved_Date) AS GAS_DATE
  FROM GasT
    LEFT JOIN GasInfoT ON GasInfoT.gasid = GasT.id
  where GasT.approved_date is not null and GasT.deleted_date is null
  GROUP BY GasT.DRIVERID,
    DATE(GasT.Approved_Date)
),
RepairData AS (
  SELECT RepairT.DRIVERID,
    SUM(RepairInfoT.totalPrice) AS REPAIR,
    DATE(RepairT.Approved_Date) AS REPAIR_DATE
  FROM RepairT
    LEFT JOIN RepairInfoT ON RepairInfoT.repairid = RepairT.id
  where RepairT.approved_date is not null and RepairT.deleted_date is null
  GROUP BY RepairT.DRIVERID,
    DATE(RepairT.Approved_Date)
),
JobData AS (
  SELECT USERT.ID AS UID,
    USERT.NAME AS USERNAME,
    DRIVERT.PLATENUM AS PLATENUM,
    JOBST.fromLoc AS FROMLOC,
    COALESCE(JOBST.MID, '') AS MID,
    JOBST.toLoc AS TOLOC,
    COUNT(CLAIMJOBT.JOBID) AS TIMES,
    JOBST.PRICE AS JP,
    JOBST.PRICE * COUNT(CLAIMJOBT.JOBID) AS TOTALPRICE,
    JOBST.SOURCE AS JOBSOURCE,
    CMPT.NAME AS CMPNAME,
    DATE(CLAIMJOBT.finished_date) AS finishDate
  FROM CLAIMJOBT
    LEFT JOIN JOBST ON CLAIMJOBT.JOBID = JOBST.ID
    LEFT JOIN USERT ON USERT.ID = CLAIMJOBT.DRIVERID
    LEFT JOIN DRIVERT ON USERT.ID = DRIVERT.ID
    LEFT JOIN CMPT ON CMPT.ID = USERT.BELONGCMP
  WHERE CLAIMJOBT.DELETED_DATE IS NULL
    AND CLAIMJOBT.finished_date BETWEEN $1 AND $2
    AND USERT.belongCMP = $3
  GROUP BY USERT.ID,
    USERT.NAME,
    DRIVERT.PLATENUM,
    JOBST.fromLoc,
    JOBST.MID,
    JOBST.toLoc,
    JOBST.PRICE,
    JOBST.SOURCE,
    CMPT.NAME,
    DATE(CLAIMJOBT.finished_date)
)
SELECT JSON_BUILD_OBJECT(
    'uid',
    MQ.UID,
    'username',
    MQ.USERNAME,
    'list',
    JSON_AGG(
      MQ.JSON_BUILD_OBJECT
      ORDER BY MQ.DATE ASC
    )
  )
FROM (
    SELECT COALESCE(JD.UID, GD.DRIVERID, RD.DRIVERID) AS UID,
      COALESCE(JD.USERNAME, U.NAME) AS USERNAME,
      COALESCE(JD.finishDate, GD.GAS_DATE, RD.REPAIR_DATE) AS DATE,
      JSON_BUILD_OBJECT(
        'date',
        COALESCE(JD.finishDate, GD.GAS_DATE, RD.REPAIR_DATE),
        'data',
        JSON_AGG(
          JSON_BUILD_OBJECT(
            'platenum',
            COALESCE(JD.PLATENUM, DR.PLATENUM, 'Unknown Plate'),
            'cmpName',
            JD.CMPNAME,
            'fromLoc',
            JD.FROMLOC,
            'mid',
            JD.MID,
            'toloc',
            JD.TOLOC,
            'count',
            JD.TIMES,
            'jp',
            JD.JP,
            'total',
            JD.TOTALPRICE,
            'ss',
            JD.JOBSOURCE
          )
        ),
        'gas',
        JSON_BUILD_OBJECT(
          'platenum',
          COALESCE(JD.PLATENUM, DR.PLATENUM, 'Unknown Plate'),
          'gasAmount',
          COALESCE(GD.GAS, 0)
        ),
        'repair',
        JSON_BUILD_OBJECT(
          'platenum',
          COALESCE(JD.PLATENUM, DR.PLATENUM, 'Unknown Plate'),
          'repairAmount',
          COALESCE(RD.REPAIR, 0)
        )
      ) AS JSON_BUILD_OBJECT
    FROM JobData JD
      FULL OUTER JOIN GasData GD ON JD.UID = GD.DRIVERID
      AND JD.finishDate = GD.GAS_DATE
      FULL OUTER JOIN RepairData RD ON COALESCE(JD.UID, GD.DRIVERID) = RD.DRIVERID
      AND COALESCE(JD.finishDate, GD.GAS_DATE) = RD.REPAIR_DATE
      LEFT JOIN USERT U ON COALESCE(JD.UID, GD.DRIVERID, RD.DRIVERID) = U.ID
      LEFT JOIN DRIVERT DR ON COALESCE(JD.UID, GD.DRIVERID, RD.DRIVERID) = DR.ID
    GROUP BY GD.GAS,
      RD.REPAIR,
      COALESCE(JD.UID, GD.DRIVERID, RD.DRIVERID),
      COALESCE(JD.USERNAME, U.NAME),
      COALESCE(JD.finishDate, GD.GAS_DATE, RD.REPAIR_DATE),
      JD.PLATENUM,
      DR.PLATENUM
  ) MQ
GROUP BY MQ.UID,
  MQ.USERNAME
ORDER BY MAX(MQ.DATE) ASC
`

type GetRevenueExcelParams struct {
	FinishedDate   sql.NullTime
	FinishedDate_2 sql.NullTime
	Belongcmp      int64
}

func (q *Queries) GetRevenueExcel(ctx context.Context, arg GetRevenueExcelParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueExcel, arg.FinishedDate, arg.FinishedDate_2, arg.Belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var json_build_object json.RawMessage
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id,
  role,
  deleted_date,
  pwd
FROM UserT
WHERE phoneNum = $1
LIMIT 1
`

type GetUserRow struct {
	ID          int64
	Role        int16
	DeletedDate sql.NullTime
	Pwd         string
}

func (q *Queries) GetUser(ctx context.Context, phonenum interface{}) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, phonenum)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.DeletedDate,
		&i.Pwd,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT UserT.id as ID,
  cmpt.name as Cmpname,
  usert.phoneNum as phoneNum,
  usert.name as Username,
  usert.belongCMP,
  usert.role,
  usert.initPwdChanged,
  UserT.Deleted_Date as Deleted_Date,
  insurances,
  registration,
  driverLicense,
  TruckLicense,
  nationalidnumber,
  plateNum,
  Approved_date
from UserT
  inner join cmpt on UserT.belongcmp = cmpt.id
  left join DriverT on driverT.id = usert.id
where UserT.id = $1
LIMIT 1
`

type GetUserByIDRow struct {
	ID               int64
	Cmpname          string
	Phonenum         interface{}
	Username         string
	Belongcmp        int64
	Role             int16
	Initpwdchanged   bool
	DeletedDate      sql.NullTime
	Insurances       sql.NullString
	Registration     sql.NullString
	Driverlicense    sql.NullString
	Trucklicense     sql.NullString
	Nationalidnumber interface{}
	Platenum         sql.NullString
	ApprovedDate     sql.NullTime
}

func (q *Queries) GetUserByID(ctx context.Context, id int64) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Cmpname,
		&i.Phonenum,
		&i.Username,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.DeletedDate,
		&i.Insurances,
		&i.Registration,
		&i.Driverlicense,
		&i.Trucklicense,
		&i.Nationalidnumber,
		&i.Platenum,
		&i.ApprovedDate,
	)
	return i, err
}

const getUserList = `-- name: GetUserList :many
SELECT json_build_object(
    'cmpid',
    cmpt.id,
    'Cmpname',
    cmpt.name,
    'list',
    json_agg(
      json_build_object(
        'id',
        UT.id,
        'phoneNum',
        UT.phonenum,
        'Role',
        UT.Role,
        'Username',
        UT.name,
        'deleted_date',
        UT.deleted_date,
        'last_modified_date',
        UT.last_modified_date
      )
      order by UT.id
    )
  )
from UserT UT
  right join cmpt on UT.belongcmp = cmpt.id
where (
    UT.id = $1
    OR $1 IS NULL
  )
  AND (
    phoneNum = $2::Text
    OR $2::Text IS NULL
  )
  AND (
    UT.name like $3
    OR $3 IS NULL
  )
  AND (
    belongcmp = $4
    OR $4 IS NULL
  )
  AND (
    cmpt.Name like $5
    OR $5 IS NULL
  )
  AND (
    (
      UT.create_date > $6
      OR $6 IS NULL
    )
    AND (
      UT.create_date < $7
      OR $7 IS NULL
    )
  )
  AND (
    (
      UT.deleted_date > $8
      OR $8 IS NULL
    )
    AND (
      UT.deleted_date < $9
      OR $9 IS NULL
    )
  )
  AND (
    (
      UT.last_modified_date > $10
      OR $10 IS NULL
    )
    AND (
      UT.last_modified_date < $11
      OR $11 IS NULL
    )
  )
  AND(UT.Deleted_Date is null)
group by cmpt.id
`

type GetUserListParams struct {
	ID                    sql.NullInt64
	PhoneNum              sql.NullString
	Name                  sql.NullString
	Belongcmp             sql.NullInt64
	BelongcmpName         sql.NullString
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	DeletedDateStart      sql.NullTime
	DeletedDateEnd        sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

func (q *Queries) GetUserList(ctx context.Context, arg GetUserListParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getUserList,
		arg.ID,
		arg.PhoneNum,
		arg.Name,
		arg.Belongcmp,
		arg.BelongcmpName,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.DeletedDateStart,
		arg.DeletedDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var json_build_object json.RawMessage
		if err := rows.Scan(&json_build_object); err != nil {
			return nil, err
		}
		items = append(items, json_build_object)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSeed = `-- name: GetUserSeed :one
SELECT seed,
  UserT.deleted_date
from UserT
  inner join cmpt on UserT.belongcmp = cmpt.id
where UserT.id = $1
LIMIT 1
`

type GetUserSeedRow struct {
	Seed        sql.NullString
	DeletedDate sql.NullTime
}

func (q *Queries) GetUserSeed(ctx context.Context, id int64) (GetUserSeedRow, error) {
	row := q.db.QueryRowContext(ctx, getUserSeed, id)
	var i GetUserSeedRow
	err := row.Scan(&i.Seed, &i.DeletedDate)
	return i, err
}

const getUserWithPendingJob = `-- name: GetUserWithPendingJob :many
SELECT JSON_BUILD_OBJECT(
    'cmpID',
    CMPT.id,
    'cmpName',
    CMPT.name,
    'users',
    JSON_AGG(
      JSON_BUILD_OBJECT(
        'userID',
        UserT.id,
        'userName',
        UserT.name,
        'jobs',
        (
          SELECT JSON_AGG(
              JSON_BUILD_OBJECT(
                'ID',
                CLAIMJOBT.id,
                'Userid',
                CLAIMJOBT.driverid,
                'CreateDate',
                CLAIMJOBT.create_date,
                'userName',
                UserT.name,
                'Cmpname',
                CMPT.name,
                'Finishdate',
                CLAIMJOBT.finished_date,
                'Cmpid',
                CMPT.id,
                'Approveddate',
                CLAIMJOBT.approved_date,
                'jobId',
                CLAIMJOBT.jobid,
                'Fromloc',
                jobst.fromloc,
                'Mid',
                jobst.mid,
                'Toloc',
                jobst.toloc
              )
            )
          FROM CLAIMJOBT
            LEFT JOIN jobst ON jobst.id = CLAIMJOBT.jobid
          WHERE CLAIMJOBT.driverID = UserT.id
            AND CLAIMJOBT.approved_date IS NULL
            AND CLAIMJOBT.deleted_date IS NULL
        )
      )
    )
  ) AS result
FROM UserT
  LEFT JOIN CMPT ON CMPT.id = UserT.belongCMP
WHERE EXISTS (
    SELECT 1
    FROM CLAIMJOBT
    WHERE CLAIMJOBT.driverID = UserT.id
      AND CLAIMJOBT.approved_date IS NULL
      AND CLAIMJOBT.deleted_date IS NULL
  )
  AND (
    CMPT.id = $1
    OR $1 IS NULL
  )
GROUP BY CMPT.id,
  CMPT.name
`

func (q *Queries) GetUserWithPendingJob(ctx context.Context, cmpid sql.NullInt64) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, getUserWithPendingJob, cmpid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []json.RawMessage
	for rows.Next() {
		var result json.RawMessage
		if err := rows.Scan(&result); err != nil {
			return nil, err
		}
		items = append(items, result)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaseRemaining = `-- name: IncreaseRemaining :one
Update JobsT
set remaining = remaining + 1,
  last_modified_date = NOW()
where id = $1
RETURNING remaining
`

func (q *Queries) IncreaseRemaining(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRowContext(ctx, increaseRemaining, id)
	var remaining int32
	err := row.Scan(&remaining)
	return remaining, err
}

const newCmp = `-- name: NewCmp :one
INSERT INTO cmpt (name)
values ($1)
RETURNING id
`

func (q *Queries) NewCmp(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, newCmp, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const newSeed = `-- name: NewSeed :exec
UPDATE UserT
set seed = $2,
  last_modified_date = NOW()
WHERE id = $1
`

type NewSeedParams struct {
	ID   int64
	Seed sql.NullString
}

func (q *Queries) NewSeed(ctx context.Context, arg NewSeedParams) error {
	_, err := q.db.ExecContext(ctx, newSeed, arg.ID, arg.Seed)
	return err
}

const setJobNoMore = `-- name: SetJobNoMore :exec
UPDATE JobsT
set finished_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) SetJobNoMore(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setJobNoMore, id)
	return err
}

const updateAlert = `-- name: UpdateAlert :exec
Update AlertT
Set alert = $2,
  last_modified_date = NOW()
where id = $1
`

type UpdateAlertParams struct {
	ID    int64
	Alert string
}

func (q *Queries) UpdateAlert(ctx context.Context, arg UpdateAlertParams) error {
	_, err := q.db.ExecContext(ctx, updateAlert, arg.ID, arg.Alert)
	return err
}

const updateCmp = `-- name: UpdateCmp :exec
UPDATE cmpt
set name = $2,
  last_modified_date = NOW()
WHERE id = $1
`

type UpdateCmpParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpdateCmp(ctx context.Context, arg UpdateCmpParams) error {
	_, err := q.db.ExecContext(ctx, updateCmp, arg.ID, arg.Name)
	return err
}

const updateDriver = `-- name: UpdateDriver :exec
UPDATE DriverT
set -- percentage = COALESCE($2, percentage),
  nationalidnumber = COALESCE($2, nationalidnumber),
  plateNum = COALESCE($3, plateNum)
WHERE id = $1
`

type UpdateDriverParams struct {
	ID               int64
	Nationalidnumber interface{}
	Platenum         string
}

func (q *Queries) UpdateDriver(ctx context.Context, arg UpdateDriverParams) error {
	_, err := q.db.ExecContext(ctx, updateDriver, arg.ID, arg.Nationalidnumber, arg.Platenum)
	return err
}

const updateDriverPic = `-- name: UpdateDriverPic :exec
UPDATE DriverT
set insurances = COALESCE($2, insurances),
  registration = COALESCE($3, registration),
  driverLicense = COALESCE($4, driverLicense),
  truckLicense = COALESCE($5, truckLicense),
  approved_date = NULL
WHERE DriverT.id = $1
`

type UpdateDriverPicParams struct {
	ID            int64
	Insurances    sql.NullString
	Registration  sql.NullString
	Driverlicense sql.NullString
	Trucklicense  sql.NullString
}

func (q *Queries) UpdateDriverPic(ctx context.Context, arg UpdateDriverPicParams) error {
	_, err := q.db.ExecContext(ctx, updateDriverPic,
		arg.ID,
		arg.Insurances,
		arg.Registration,
		arg.Driverlicense,
		arg.Trucklicense,
	)
	return err
}

const updateGas = `-- name: UpdateGas :exec
UPDATE GasInfoT
SET totalPrice = $2,
  last_modified_date = NOW()
WHERE GasInfoT.id = $1
`

type UpdateGasParams struct {
	ID         int64
	Totalprice int64
}

func (q *Queries) UpdateGas(ctx context.Context, arg UpdateGasParams) error {
	_, err := q.db.ExecContext(ctx, updateGas, arg.ID, arg.Totalprice)
	return err
}

const updateItem = `-- name: UpdateItem :exec
UPDATE RepairInfoT
SET totalPrice = $2,
  last_modified_date = NOW()
WHERE RepairInfoT.id = $1
`

type UpdateItemParams struct {
	ID         int64
	Totalprice int64
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.ExecContext(ctx, updateItem, arg.ID, arg.Totalprice)
	return err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobsT
set fromLoc = $1,
  mid = $2,
  toLoc = $3,
  price = $4,
  remaining = $5,
  belongCMP = $6,
  source = $7,
  -- jobDate = $8,
  memo = $8,
  -- close_date = $9,
  last_modified_date = NOW()
where id = $9
RETURNING id
`

type UpdateJobParams struct {
	Fromloc   string
	Mid       sql.NullString
	Toloc     string
	Price     int32
	Remaining int32
	Belongcmp int64
	Source    string
	Memo      sql.NullString
	ID        int64
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateJob,
		arg.Fromloc,
		arg.Mid,
		arg.Toloc,
		arg.Price,
		arg.Remaining,
		arg.Belongcmp,
		arg.Source,
		arg.Memo,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateLastAlert = `-- name: UpdateLastAlert :exec
Update driverT
set lastAlert = $2
where id = $1
`

type UpdateLastAlertParams struct {
	ID        int64
	Lastalert sql.NullInt64
}

func (q *Queries) UpdateLastAlert(ctx context.Context, arg UpdateLastAlertParams) error {
	_, err := q.db.ExecContext(ctx, updateLastAlert, arg.ID, arg.Lastalert)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE UserT
set phoneNum = COALESCE($2, phoneNum),
  name = COALESCE($3, name),
  belongCMP = COALESCE($4, belongCMP),
  role = COALESCE($5, role),
  last_modified_date = NOW()
WHERE UserT.id = $1
`

type UpdateUserParams struct {
	ID        int64
	Phonenum  interface{}
	Name      string
	Belongcmp int64
	Role      int16
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.ID,
		arg.Phonenum,
		arg.Name,
		arg.Belongcmp,
		arg.Role,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE UserT
set pwd = $2,
  initPwdChanged = True,
  last_modified_date = NOW()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID  int64
	Pwd string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.ID, arg.Pwd)
	return err
}

const userHasModified = `-- name: UserHasModified :exec
UPDATE UserT
set last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) UserHasModified(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, userHasModified, id)
	return err
}
