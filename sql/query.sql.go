// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveFinishedJob = `-- name: ApproveFinishedJob :exec
Update ClaimJobT set Approved_By = $2, approved_date = NOW(), last_modified_date = NOW() where id = $1
`

type ApproveFinishedJobParams struct {
	ID         int64
	ApprovedBy pgtype.Int8
}

func (q *Queries) ApproveFinishedJob(ctx context.Context, arg ApproveFinishedJobParams) error {
	_, err := q.db.Exec(ctx, approveFinishedJob, arg.ID, arg.ApprovedBy)
	return err
}

const claimJob = `-- name: ClaimJob :one
INSERT into ClaimJobT (
    jobID,
    driverID
) values (
    $1,
    $2
) RETURNING id
`

type ClaimJobParams struct {
	Jobid    int64
	Driverid int64
}

func (q *Queries) ClaimJob(ctx context.Context, arg ClaimJobParams) (int64, error) {
	row := q.db.QueryRow(ctx, claimJob, arg.Jobid, arg.Driverid)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO UserT(
    pwd, name, role, belongcmp, phoneNum
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateAdminParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp pgtype.Int8
	Phonenum  interface{}
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAdmin,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDriverInfo = `-- name: CreateDriverInfo :one
insert into driverT (id, percentage, nationalidnumber) 
    values ($1, $2, $3)
RETURNING id
`

type CreateDriverInfoParams struct {
	ID               int64
	Percentage       int16
	Nationalidnumber interface{}
}

func (q *Queries) CreateDriverInfo(ctx context.Context, arg CreateDriverInfoParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDriverInfo, arg.ID, arg.Percentage, arg.Nationalidnumber)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO JobsT (
    from_loc,
    mid,
    to_loc,
    price,
    estimated,
    remaining,
    belongCMP,
    source,
    jobDate,
    memo,
    end_date
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING id
`

type CreateJobParams struct {
	FromLoc   string
	Mid       pgtype.Text
	ToLoc     string
	Price     int16
	Estimated int16
	Belongcmp int64
	Source    string
	Jobdate   pgtype.Timestamp
	Memo      pgtype.Text
	EndDate   pgtype.Timestamp
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int64, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Price,
		arg.Estimated,
		arg.Belongcmp,
		arg.Source,
		arg.Jobdate,
		arg.Memo,
		arg.EndDate,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO UserT(
    pwd, name, role, belongcmp, phoneNum
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateUserParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp pgtype.Int8
	Phonenum  interface{}
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const decreaseRemaining = `-- name: DecreaseRemaining :exec
Update JobsT set remaining = remaining - 1, last_modified_date = NOW() where id = $1
`

func (q *Queries) DecreaseRemaining(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decreaseRemaining, id)
	return err
}

const deleteClaimedJob = `-- name: DeleteClaimedJob :exec
Update ClaimJobT Set
    deleted_by = $2,
    deleted_date = NOW(),
    last_modified_date = NOW()
    where id = $1
`

type DeleteClaimedJobParams struct {
	ID        int64
	DeletedBy pgtype.Int8
}

func (q *Queries) DeleteClaimedJob(ctx context.Context, arg DeleteClaimedJobParams) error {
	_, err := q.db.Exec(ctx, deleteClaimedJob, arg.ID, arg.DeletedBy)
	return err
}

const deleteCmp = `-- name: DeleteCmp :exec
UPDATE cmpt
  set deleted_date= NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCmp(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCmp, id)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
UPDATE JobsT 
  set deleted_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteJob, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE UserT
  set deleted_date= NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const finishClamedJob = `-- name: FinishClamedJob :exec
Update ClaimJobT Set
    finished_date = NOW(),
    percentage = (SELECT percentage from driverT where usert.id = (SELECT driverID from ClaimJobT where ClaimJobT.id = $1)),
    last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) FinishClamedJob(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, finishClamedJob, id)
	return err
}

const getAllCmp = `-- name: GetAllCmp :many
SELECT id, name, create_date, deleted_date, last_modified_date from cmpt
`

func (q *Queries) GetAllCmp(ctx context.Context) ([]Cmpt, error) {
	rows, err := q.db.Query(ctx, getAllCmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cmpt
	for rows.Next() {
		var i Cmpt
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, jobdate, memo, create_date, end_date, deleted_date, finished_date, last_modified_date from JobsT
`

func (q *Queries) GetAllJobs(ctx context.Context) ([]Jobst, error) {
	rows, err := q.db.Query(ctx, getAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobst
	for rows.Next() {
		var i Jobst
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Jobdate,
			&i.Memo,
			&i.CreateDate,
			&i.EndDate,
			&i.DeletedDate,
			&i.FinishedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsByCmp = `-- name: GetAllJobsByCmp :many
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, jobdate, memo, create_date, end_date, deleted_date, finished_date, last_modified_date from JobsT where belongcmp = $1
`

func (q *Queries) GetAllJobsByCmp(ctx context.Context, belongcmp int64) ([]Jobst, error) {
	rows, err := q.db.Query(ctx, getAllJobsByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobst
	for rows.Next() {
		var i Jobst
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Jobdate,
			&i.Memo,
			&i.CreateDate,
			&i.EndDate,
			&i.DeletedDate,
			&i.FinishedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJob = `-- name: GetClaimedJob :one
SELECT t2.id, t1.id, t1.from_loc, t1.mid, t1.to_loc, t1.price, t1.estimated, t1.remaining, t1.belongcmp, t1.source, t1.jobdate, t1.memo, t1.create_date, t1.end_date, t1.deleted_date, t1.finished_date, t1.last_modified_date  FROM ClaimJobT t2 inner join JobsT t1 on t1.id = t2.jobID where t2.driverID = $1 and (t2.deleted_date IS NULL and t2.finished_date IS NULL) order by t2.create_date LIMIT 1
`

type GetClaimedJobRow struct {
	ID               int64
	ID_2             int64
	FromLoc          string
	Mid              pgtype.Text
	ToLoc            string
	Price            int16
	Estimated        int16
	Remaining        int16
	Belongcmp        int64
	Source           string
	Jobdate          pgtype.Timestamp
	Memo             pgtype.Text
	CreateDate       pgtype.Timestamp
	EndDate          pgtype.Timestamp
	DeletedDate      pgtype.Timestamp
	FinishedDate     pgtype.Timestamp
	LastModifiedDate pgtype.Timestamp
}

func (q *Queries) GetClaimedJob(ctx context.Context, driverid int64) (GetClaimedJobRow, error) {
	row := q.db.QueryRow(ctx, getClaimedJob, driverid)
	var i GetClaimedJobRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.FromLoc,
		&i.Mid,
		&i.ToLoc,
		&i.Price,
		&i.Estimated,
		&i.Remaining,
		&i.Belongcmp,
		&i.Source,
		&i.Jobdate,
		&i.Memo,
		&i.CreateDate,
		&i.EndDate,
		&i.DeletedDate,
		&i.FinishedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getCmp = `-- name: GetCmp :one
SELECT cmpt.id, cmpt.name, cmpt.create_date, cmpt.deleted_date, cmpt.last_modified_date, usert.id, phonenum, pwd, usert.name, belongcmp, role, initpwdchanged, usert.create_date, usert.deleted_date, usert.last_modified_date FROM cmpt
inner join usert
on cmpt.id = usert.belongcmp AND (usert.role=200 OR usert.role=100)
where cmpt.id = $1
`

type GetCmpRow struct {
	ID                 int64
	Name               string
	CreateDate         pgtype.Timestamp
	DeletedDate        pgtype.Timestamp
	LastModifiedDate   pgtype.Timestamp
	ID_2               int64
	Phonenum           interface{}
	Pwd                string
	Name_2             string
	Belongcmp          pgtype.Int8
	Role               int16
	Initpwdchanged     bool
	CreateDate_2       pgtype.Timestamp
	DeletedDate_2      pgtype.Timestamp
	LastModifiedDate_2 pgtype.Timestamp
}

func (q *Queries) GetCmp(ctx context.Context, id int64) (GetCmpRow, error) {
	row := q.db.QueryRow(ctx, getCmp, id)
	var i GetCmpRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
		&i.ID_2,
		&i.Phonenum,
		&i.Pwd,
		&i.Name_2,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.CreateDate_2,
		&i.DeletedDate_2,
		&i.LastModifiedDate_2,
	)
	return i, err
}

const getDriverRevenue = `-- name: GetDriverRevenue :many
SELECT t1.percentage*t2.price as earn from ClaimJobT t1 inner join JobsT t2 on t1.jobID = t2.id where t1.driverID = $1 and (t1.finished_date IS NOT NULL 
    and approved_date IS NOT NULL and deleted_date IS NOT NULL) and t1.finished_date 
    between $2 and $3
`

type GetDriverRevenueParams struct {
	Driverid       int64
	FinishedDate   pgtype.Timestamp
	FinishedDate_2 pgtype.Timestamp
}

func (q *Queries) GetDriverRevenue(ctx context.Context, arg GetDriverRevenueParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, getDriverRevenue, arg.Driverid, arg.FinishedDate, arg.FinishedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var earn int32
		if err := rows.Scan(&earn); err != nil {
			return nil, err
		}
		items = append(items, earn)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, role, deleted_date FROM  UserT
WHERE phoneNum=$1 AND pwd=$2 LIMIT 1
`

type GetUserParams struct {
	Phonenum interface{}
	Pwd      string
}

type GetUserRow struct {
	ID          int64
	Role        int16
	DeletedDate pgtype.Timestamp
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, arg.Phonenum, arg.Pwd)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.Role, &i.DeletedDate)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, phonenum, pwd, name, belongcmp, role, initpwdchanged, create_date, deleted_date, last_modified_date from UserT where id=$1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (Usert, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i Usert
	err := row.Scan(
		&i.ID,
		&i.Phonenum,
		&i.Pwd,
		&i.Name,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const increaseRemaining = `-- name: IncreaseRemaining :exec
Update JobsT set remaining = remaining + 1, last_modified_date = NOW() where id = $1
`

func (q *Queries) IncreaseRemaining(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, increaseRemaining, id)
	return err
}

const newCmp = `-- name: NewCmp :one
INSERT INTO cmpt (name) values ($1) RETURNING id
`

func (q *Queries) NewCmp(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, newCmp, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const setJobNoMore = `-- name: SetJobNoMore :exec
UPDATE JobsT 
  set finished_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) SetJobNoMore(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, setJobNoMore, id)
	return err
}

const updateCmp = `-- name: UpdateCmp :exec
UPDATE cmpt
    set
    name = $2,
    last_modified_date = NOW()
WHERE id = $1
`

type UpdateCmpParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpdateCmp(ctx context.Context, arg UpdateCmpParams) error {
	_, err := q.db.Exec(ctx, updateCmp, arg.ID, arg.Name)
	return err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobsT set 
    from_loc = $1,
    mid = $2,
    to_loc = $3,
    price = $4,
    remaining = $5,
    belongCMP = $6,
    source = $7,
    jobDate = $8,
    memo = $9,
    end_date = $10,
    last_modified_date = NOW()
where id = $11
 RETURNING id
`

type UpdateJobParams struct {
	FromLoc   string
	Mid       pgtype.Text
	ToLoc     string
	Price     int16
	Remaining int16
	Belongcmp int64
	Source    string
	Jobdate   pgtype.Timestamp
	Memo      pgtype.Text
	EndDate   pgtype.Timestamp
	ID        int64
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Price,
		arg.Remaining,
		arg.Belongcmp,
		arg.Source,
		arg.Jobdate,
		arg.Memo,
		arg.EndDate,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE UserT
  set 
  pwd = $2,
  role = $3,
  last_modified_date = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID   int64
	Pwd  string
	Role int16
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.ID, arg.Pwd, arg.Role)
	return err
}
