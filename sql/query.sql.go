// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sql

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const approveFinishedJob = `-- name: ApproveFinishedJob :exec
Update ClaimJobT set Approved_By = $2, approved_date = NOW(), last_modified_date = NOW() where id = $1
`

type ApproveFinishedJobParams struct {
	ID         int64
	ApprovedBy sql.NullInt64
}

func (q *Queries) ApproveFinishedJob(ctx context.Context, arg ApproveFinishedJobParams) error {
	_, err := q.db.ExecContext(ctx, approveFinishedJob, arg.ID, arg.ApprovedBy)
	return err
}

const claimJob = `-- name: ClaimJob :one
INSERT into ClaimJobT (
    jobID,
    driverID
) values (
    $1,
    $2
) RETURNING id
`

type ClaimJobParams struct {
	Jobid    int64
	Driverid int64
}

func (q *Queries) ClaimJob(ctx context.Context, arg ClaimJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, claimJob, arg.Jobid, arg.Driverid)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO UserT(
    pwd, name, role, belongcmp, phoneNum
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateAdminParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp int64
	Phonenum  interface{}
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAdmin,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDriverInfo = `-- name: CreateDriverInfo :one
insert into driverT (id, percentage, nationalidnumber) 
    values ($1, $2, $3)
RETURNING id
`

type CreateDriverInfoParams struct {
	ID               int64
	Percentage       int16
	Nationalidnumber interface{}
}

func (q *Queries) CreateDriverInfo(ctx context.Context, arg CreateDriverInfoParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createDriverInfo, arg.ID, arg.Percentage, arg.Nationalidnumber)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createJob = `-- name: CreateJob :one
INSERT INTO JobsT (
    from_loc,
    mid,
    to_loc,
    price,
    estimated,
    remaining,
    belongCMP,
    source,
    jobDate,
    memo,
    close_date
) values (
    $1,
    $2,
    $3,
    $4,
    $5,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING id
`

type CreateJobParams struct {
	FromLoc   string
	Mid       sql.NullString
	ToLoc     string
	Price     int16
	Estimated int16
	Belongcmp int64
	Source    string
	Jobdate   time.Time
	Memo      sql.NullString
	CloseDate sql.NullTime
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Price,
		arg.Estimated,
		arg.Belongcmp,
		arg.Source,
		arg.Jobdate,
		arg.Memo,
		arg.CloseDate,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createNewRepair = `-- name: CreateNewRepair :one
INSERT into repairT (type, driverID, repairInfo) values ($1, $2, $3) RETURNING id
`

type CreateNewRepairParams struct {
	Type       string
	Driverid   int64
	Repairinfo json.RawMessage
}

func (q *Queries) CreateNewRepair(ctx context.Context, arg CreateNewRepairParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createNewRepair, arg.Type, arg.Driverid, arg.Repairinfo)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO UserT(
    pwd, name, role, belongcmp, phoneNum
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type CreateUserParams struct {
	Pwd       string
	Name      string
	Role      int16
	Belongcmp int64
	Phonenum  interface{}
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Pwd,
		arg.Name,
		arg.Role,
		arg.Belongcmp,
		arg.Phonenum,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const decreaseRemaining = `-- name: DecreaseRemaining :exec
Update JobsT set remaining = remaining - 1, last_modified_date = NOW() where id = $1
`

func (q *Queries) DecreaseRemaining(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, decreaseRemaining, id)
	return err
}

const deleteClaimedJob = `-- name: DeleteClaimedJob :exec
Update ClaimJobT Set
    deleted_by = $2,
    deleted_date = NOW(),
    last_modified_date = NOW()
    where id = $1
`

type DeleteClaimedJobParams struct {
	ID        int64
	DeletedBy sql.NullInt64
}

func (q *Queries) DeleteClaimedJob(ctx context.Context, arg DeleteClaimedJobParams) error {
	_, err := q.db.ExecContext(ctx, deleteClaimedJob, arg.ID, arg.DeletedBy)
	return err
}

const deleteCmp = `-- name: DeleteCmp :exec
UPDATE cmpt
  set deleted_date= NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteCmp(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCmp, id)
	return err
}

const deleteJob = `-- name: DeleteJob :exec
UPDATE JobsT 
  set deleted_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteJob, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE UserT
  set deleted_date= NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const finishClamedJob = `-- name: FinishClamedJob :exec
Update ClaimJobT Set
    finished_date = NOW(),
    percentage = (SELECT percentage from driverT where usert.id = (SELECT driverID from ClaimJobT where ClaimJobT.id = $1)),
    last_modified_date = NOW()
WHERE id = $1 and ClaimJobT.Driverid = $2
`

type FinishClamedJobParams struct {
	ID       int64
	Driverid int64
}

func (q *Queries) FinishClamedJob(ctx context.Context, arg FinishClamedJobParams) error {
	_, err := q.db.ExecContext(ctx, finishClamedJob, arg.ID, arg.Driverid)
	return err
}

const getAllClaimedJobs = `-- name: GetAllClaimedJobs :many
SELECT id, jobid, driverid, percentage, finished_date, create_date, deleted_date, deleted_by, last_modified_date, approved_by, approved_date from ClaimJobT
`

func (q *Queries) GetAllClaimedJobs(ctx context.Context) ([]Claimjobt, error) {
	rows, err := q.db.QueryContext(ctx, getAllClaimedJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Claimjobt
	for rows.Next() {
		var i Claimjobt
		if err := rows.Scan(
			&i.ID,
			&i.Jobid,
			&i.Driverid,
			&i.Percentage,
			&i.FinishedDate,
			&i.CreateDate,
			&i.DeletedDate,
			&i.DeletedBy,
			&i.LastModifiedDate,
			&i.ApprovedBy,
			&i.ApprovedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllCmp = `-- name: GetAllCmp :many
SELECT id, name, create_date, deleted_date, last_modified_date from cmpt
`

func (q *Queries) GetAllCmp(ctx context.Context) ([]Cmpt, error) {
	rows, err := q.db.QueryContext(ctx, getAllCmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cmpt
	for rows.Next() {
		var i Cmpt
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, jobdate, memo, close_date, create_date, deleted_date, last_modified_date from JobsT
`

func (q *Queries) GetAllJobs(ctx context.Context) ([]Jobst, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobst
	for rows.Next() {
		var i Jobst
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Jobdate,
			&i.Memo,
			&i.CloseDate,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllJobsByCmp = `-- name: GetAllJobsByCmp :many
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, jobdate, memo, close_date, create_date, deleted_date, last_modified_date from JobsT where belongcmp = $1
`

func (q *Queries) GetAllJobsByCmp(ctx context.Context, belongcmp int64) ([]Jobst, error) {
	rows, err := q.db.QueryContext(ctx, getAllJobsByCmp, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jobst
	for rows.Next() {
		var i Jobst
		if err := rows.Scan(
			&i.ID,
			&i.FromLoc,
			&i.Mid,
			&i.ToLoc,
			&i.Price,
			&i.Estimated,
			&i.Remaining,
			&i.Belongcmp,
			&i.Source,
			&i.Jobdate,
			&i.Memo,
			&i.CloseDate,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRepairByCMP = `-- name: GetAllRepairByCMP :many
SELECT repairt.id, type, driverid, repairinfo, repairt.create_date, approved_date, repairt.deleted_date, repairt.last_modified_date, usert.id, phonenum, pwd, name, belongcmp, role, initpwdchanged, usert.create_date, usert.deleted_date, usert.last_modified_date from repairT inner join UserT on repairT.Driverid = UserT.id where UserT.belongCMP= $1
`

type GetAllRepairByCMPRow struct {
	ID                 int64
	Type               string
	Driverid           int64
	Repairinfo         json.RawMessage
	CreateDate         time.Time
	ApprovedDate       sql.NullTime
	DeletedDate        sql.NullTime
	LastModifiedDate   time.Time
	ID_2               int64
	Phonenum           interface{}
	Pwd                string
	Name               string
	Belongcmp          int64
	Role               int16
	Initpwdchanged     bool
	CreateDate_2       time.Time
	DeletedDate_2      sql.NullTime
	LastModifiedDate_2 time.Time
}

func (q *Queries) GetAllRepairByCMP(ctx context.Context, belongcmp int64) ([]GetAllRepairByCMPRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllRepairByCMP, belongcmp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRepairByCMPRow
	for rows.Next() {
		var i GetAllRepairByCMPRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Driverid,
			&i.Repairinfo,
			&i.CreateDate,
			&i.ApprovedDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
			&i.ID_2,
			&i.Phonenum,
			&i.Pwd,
			&i.Name,
			&i.Belongcmp,
			&i.Role,
			&i.Initpwdchanged,
			&i.CreateDate_2,
			&i.DeletedDate_2,
			&i.LastModifiedDate_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRepairByDriverID = `-- name: GetAllRepairByDriverID :many
SELECT id, type, driverid, repairinfo, create_date, approved_date, deleted_date, last_modified_date from repairT where driverID = $1
`

func (q *Queries) GetAllRepairByDriverID(ctx context.Context, driverid int64) ([]Repairt, error) {
	rows, err := q.db.QueryContext(ctx, getAllRepairByDriverID, driverid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repairt
	for rows.Next() {
		var i Repairt
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Driverid,
			&i.Repairinfo,
			&i.CreateDate,
			&i.ApprovedDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClaimedJobByID = `-- name: GetClaimedJobByID :one
SELECT id, jobid, driverid, percentage, finished_date, create_date, deleted_date, deleted_by, last_modified_date, approved_by, approved_date from ClaimJobT where id = $1
`

func (q *Queries) GetClaimedJobByID(ctx context.Context, id int64) (Claimjobt, error) {
	row := q.db.QueryRowContext(ctx, getClaimedJobByID, id)
	var i Claimjobt
	err := row.Scan(
		&i.ID,
		&i.Jobid,
		&i.Driverid,
		&i.Percentage,
		&i.FinishedDate,
		&i.CreateDate,
		&i.DeletedDate,
		&i.DeletedBy,
		&i.LastModifiedDate,
		&i.ApprovedBy,
		&i.ApprovedDate,
	)
	return i, err
}

const getCmp = `-- name: GetCmp :one
SELECT cmpt.id, cmpt.name, cmpt.create_date, cmpt.deleted_date, cmpt.last_modified_date, usert.id, phonenum, pwd, usert.name, belongcmp, role, initpwdchanged, usert.create_date, usert.deleted_date, usert.last_modified_date FROM cmpt
inner join usert
on cmpt.id = usert.belongcmp AND (usert.role=200 OR usert.role=100)
where cmpt.id = $1
`

type GetCmpRow struct {
	ID                 int64
	Name               string
	CreateDate         time.Time
	DeletedDate        sql.NullTime
	LastModifiedDate   time.Time
	ID_2               int64
	Phonenum           interface{}
	Pwd                string
	Name_2             string
	Belongcmp          int64
	Role               int16
	Initpwdchanged     bool
	CreateDate_2       time.Time
	DeletedDate_2      sql.NullTime
	LastModifiedDate_2 time.Time
}

func (q *Queries) GetCmp(ctx context.Context, id int64) (GetCmpRow, error) {
	row := q.db.QueryRowContext(ctx, getCmp, id)
	var i GetCmpRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
		&i.ID_2,
		&i.Phonenum,
		&i.Pwd,
		&i.Name_2,
		&i.Belongcmp,
		&i.Role,
		&i.Initpwdchanged,
		&i.CreateDate_2,
		&i.DeletedDate_2,
		&i.LastModifiedDate_2,
	)
	return i, err
}

const getCurrentClaimedJob = `-- name: GetCurrentClaimedJob :one
SELECT t2.id, t1.id, t1.from_loc, t1.mid, t1.to_loc, t1.price, t1.estimated, t1.remaining, t1.belongcmp, t1.source, t1.jobdate, t1.memo, t1.close_date, t1.create_date, t1.deleted_date, t1.last_modified_date  FROM ClaimJobT t2 inner join JobsT t1 on t1.id = t2.jobID where t2.driverID = $1 and (t2.deleted_date IS NULL and t2.finished_date IS NULL) order by t2.create_date LIMIT 1
`

type GetCurrentClaimedJobRow struct {
	ID               int64
	ID_2             int64
	FromLoc          string
	Mid              sql.NullString
	ToLoc            string
	Price            int16
	Estimated        int16
	Remaining        int16
	Belongcmp        int64
	Source           string
	Jobdate          time.Time
	Memo             sql.NullString
	CloseDate        sql.NullTime
	CreateDate       time.Time
	DeletedDate      sql.NullTime
	LastModifiedDate time.Time
}

func (q *Queries) GetCurrentClaimedJob(ctx context.Context, driverid int64) (GetCurrentClaimedJobRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentClaimedJob, driverid)
	var i GetCurrentClaimedJobRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.FromLoc,
		&i.Mid,
		&i.ToLoc,
		&i.Price,
		&i.Estimated,
		&i.Remaining,
		&i.Belongcmp,
		&i.Source,
		&i.Jobdate,
		&i.Memo,
		&i.CloseDate,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getDriverRevenue = `-- name: GetDriverRevenue :many
SELECT t1.percentage*t2.price as earn from ClaimJobT t1 inner join JobsT t2 on t1.jobID = t2.id where t1.driverID = $1 and (t1.finished_date IS NOT NULL 
    and approved_date IS NOT NULL and deleted_date IS NOT NULL) and t1.finished_date 
    between $2 and $3
`

type GetDriverRevenueParams struct {
	Driverid       int64
	FinishedDate   sql.NullTime
	FinishedDate_2 sql.NullTime
}

func (q *Queries) GetDriverRevenue(ctx context.Context, arg GetDriverRevenueParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getDriverRevenue, arg.Driverid, arg.FinishedDate, arg.FinishedDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var earn int32
		if err := rows.Scan(&earn); err != nil {
			return nil, err
		}
		items = append(items, earn)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobById = `-- name: GetJobById :one
SELECT id, from_loc, mid, to_loc, price, estimated, remaining, belongcmp, source, jobdate, memo, close_date, create_date, deleted_date, last_modified_date from JobsT where id = $1 LIMIT 1
`

func (q *Queries) GetJobById(ctx context.Context, id int64) (Jobst, error) {
	row := q.db.QueryRowContext(ctx, getJobById, id)
	var i Jobst
	err := row.Scan(
		&i.ID,
		&i.FromLoc,
		&i.Mid,
		&i.ToLoc,
		&i.Price,
		&i.Estimated,
		&i.Remaining,
		&i.Belongcmp,
		&i.Source,
		&i.Jobdate,
		&i.Memo,
		&i.CloseDate,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getRepairByID = `-- name: GetRepairByID :one
SELECT id, type, driverid, repairinfo, create_date, approved_date, deleted_date, last_modified_date from repairT where id = $1
`

func (q *Queries) GetRepairByID(ctx context.Context, id int64) (Repairt, error) {
	row := q.db.QueryRowContext(ctx, getRepairByID, id)
	var i Repairt
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Driverid,
		&i.Repairinfo,
		&i.CreateDate,
		&i.ApprovedDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, role, deleted_date FROM  UserT
WHERE phoneNum=$1 AND pwd=$2 LIMIT 1
`

type GetUserParams struct {
	Phonenum interface{}
	Pwd      string
}

type GetUserRow struct {
	ID          int64
	Role        int16
	DeletedDate sql.NullTime
}

func (q *Queries) GetUser(ctx context.Context, arg GetUserParams) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, arg.Phonenum, arg.Pwd)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.Role, &i.DeletedDate)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT UserT.id, phoneNum, UserT.name, cmpt.name, role, UserT.create_date, UserT.deleted_date, UserT.last_modified_date 
from UserT 
inner join cmpt on UserT.belongcmp = cmpt.id 
where UserT.id=$1 LIMIT 1
`

type GetUserByIDRow struct {
	ID               int64
	Phonenum         interface{}
	Name             string
	Name_2           string
	Role             int16
	CreateDate       time.Time
	DeletedDate      sql.NullTime
	LastModifiedDate time.Time
}

func (q *Queries) GetUserByID(ctx context.Context, id int64) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Phonenum,
		&i.Name,
		&i.Name_2,
		&i.Role,
		&i.CreateDate,
		&i.DeletedDate,
		&i.LastModifiedDate,
	)
	return i, err
}

const getUserList = `-- name: GetUserList :many
SELECT UserT.id, phoneNum, UserT.name, cmpt.name, role, UserT.create_date, UserT.deleted_date, UserT.last_modified_date 
from UserT 
inner join cmpt on UserT.belongcmp = cmpt.id 
where 
(UserT.id = $1 OR $1 IS NULL)AND
(phoneNum = $2::Text OR $2::Text IS NULL)AND
(UserT.name = $3 OR $3 IS NULL)AND
(belongcmp = $4 OR $4 IS NULL)AND
((UserT.create_date > $5 OR $5 IS NULL)
 AND (UserT.create_date < $6 OR $6 IS NULL)) AND
((UserT.deleted_date > $7 OR $7 IS NULL)
 AND (UserT.deleted_date < $8 OR $8 IS NULL)) AND
((UserT.last_modified_date > $9 OR $9 IS NULL) 
AND (UserT.last_modified_date < $10 OR $10 IS NULL))
`

type GetUserListParams struct {
	ID                    sql.NullInt64
	PhoneNum              sql.NullString
	Name                  sql.NullString
	Belongcmp             sql.NullInt64
	CreateDateStart       sql.NullTime
	CreateDateEnd         sql.NullTime
	DeletedDateStart      sql.NullTime
	DeletedDateEnd        sql.NullTime
	LastModifiedDateStart sql.NullTime
	LastModifiedDateEnd   sql.NullTime
}

type GetUserListRow struct {
	ID               int64
	Phonenum         interface{}
	Name             string
	Name_2           string
	Role             int16
	CreateDate       time.Time
	DeletedDate      sql.NullTime
	LastModifiedDate time.Time
}

func (q *Queries) GetUserList(ctx context.Context, arg GetUserListParams) ([]GetUserListRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserList,
		arg.ID,
		arg.PhoneNum,
		arg.Name,
		arg.Belongcmp,
		arg.CreateDateStart,
		arg.CreateDateEnd,
		arg.DeletedDateStart,
		arg.DeletedDateEnd,
		arg.LastModifiedDateStart,
		arg.LastModifiedDateEnd,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserListRow
	for rows.Next() {
		var i GetUserListRow
		if err := rows.Scan(
			&i.ID,
			&i.Phonenum,
			&i.Name,
			&i.Name_2,
			&i.Role,
			&i.CreateDate,
			&i.DeletedDate,
			&i.LastModifiedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const increaseRemaining = `-- name: IncreaseRemaining :exec
Update JobsT set remaining = remaining + 1, last_modified_date = NOW() where id = $1
`

func (q *Queries) IncreaseRemaining(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, increaseRemaining, id)
	return err
}

const newCmp = `-- name: NewCmp :one
INSERT INTO cmpt (name) values ($1) RETURNING id
`

func (q *Queries) NewCmp(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, newCmp, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const setJobNoMore = `-- name: SetJobNoMore :exec
UPDATE JobsT 
  set finished_date = NOW(),
  last_modified_date = NOW()
WHERE id = $1
`

func (q *Queries) SetJobNoMore(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setJobNoMore, id)
	return err
}

const updateCmp = `-- name: UpdateCmp :exec
UPDATE cmpt
    set
    name = $2,
    last_modified_date = NOW()
WHERE id = $1
`

type UpdateCmpParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpdateCmp(ctx context.Context, arg UpdateCmpParams) error {
	_, err := q.db.ExecContext(ctx, updateCmp, arg.ID, arg.Name)
	return err
}

const updateJob = `-- name: UpdateJob :one
UPDATE JobsT set 
    from_loc = $1,
    mid = $2,
    to_loc = $3,
    price = $4,
    remaining = $5,
    belongCMP = $6,
    source = $7,
    jobDate = $8,
    memo = $9,
    close_date = $10,
    last_modified_date = NOW()
where id = $11
 RETURNING id
`

type UpdateJobParams struct {
	FromLoc   string
	Mid       sql.NullString
	ToLoc     string
	Price     int16
	Remaining int16
	Belongcmp int64
	Source    string
	Jobdate   time.Time
	Memo      sql.NullString
	CloseDate sql.NullTime
	ID        int64
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateJob,
		arg.FromLoc,
		arg.Mid,
		arg.ToLoc,
		arg.Price,
		arg.Remaining,
		arg.Belongcmp,
		arg.Source,
		arg.Jobdate,
		arg.Memo,
		arg.CloseDate,
		arg.ID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE UserT
  set 
  pwd = $2,
  role = $3,
  last_modified_date = NOW()
WHERE id = $1
`

type UpdateUserParams struct {
	ID   int64
	Pwd  string
	Role int16
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.ID, arg.Pwd, arg.Role)
	return err
}
